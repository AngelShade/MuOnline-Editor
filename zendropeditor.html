<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Drop Rate Editor (Zen & Excellent Options)</title>

    <!-- Fonts and Icons from existing theme -->
    <link rel="preconnect" href="https://fonts.googleapis.com">
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
    <link href="https://fonts.googleapis.com/css2?family=Fira+Code:wght@500;700&family=Inter:wght@400;600;700&display=swap" rel="stylesheet">
    <link rel="stylesheet" href="css/style.css">
    <script src="https://unpkg.com/lucide@latest"></script>
    <script src="js/utils.js"></script>
</head>
<body>
    <!-- Author Modal (reused from monster editor) -->
    <div class="modal" id="authorModal"><div class="author-modal-content"><h2>Welcome</h2><p>Please enter your name to track your changes.</p><input type="text" id="initialAuthorName" placeholder="Your Name..." oninput="this.value ? document.getElementById('saveInitialAuthorBtn').disabled=false : document.getElementById('saveInitialAuthorBtn').disabled=true"><button id="saveInitialAuthorBtn" class="btn btn-primary" onclick="saveInitialAuthorName()" disabled>Save & Begin</button></div></div>
    
    <!-- Confirmation Modal (reused from monster editor) -->
    <div class="modal" id="confirmModal">
        <div class="modal-content glass-effect" style="max-width: 500px;">
            <div class="modal-header">
                <h2 id="confirmTitle">Are you sure?</h2>
                <button class="close-btn" onclick="closeConfirmModal()"><i data-lucide="x"></i></button>
            </div>
            <div class="modal-body">
                <p id="confirmMessage">This action cannot be undone.</p>
            </div>
            <div class="modal-footer">
                <button class="btn btn-outline" onclick="closeConfirmModal()">Cancel</button>
                <button id="confirmButton" class="btn btn-danger">Confirm</button>
            </div>
        </div>
    </div>

    <!-- NEW: Item View Modal -->
    <div class="modal" id="itemViewModal">
        <div class="modal-content glass-effect item-list-modal">
            <div class="modal-header">
                <h2 id="itemViewModalTitle">Items in Category: Swords (Kind A: 0)</h2>
                <button class="close-btn" onclick="closeModal('itemViewModal')"><i data-lucide="x"></i></button>
            </div>
            <div class="modal-body">
                <p id="itemViewDescription" style="color: var(--accent-amber); margin-bottom: 15px; font-size: 14px;"></p>
                <ul id="itemViewList">
                    <div class="empty-state">Loading item list...</div>
                </ul>
            </div>
            <div class="modal-footer">
                <button class="btn btn-primary" onclick="closeModal('itemViewModal')">Close</button>
            </div>
        </div>
    </div>
    
    <!-- Main Container -->
    <div class="container glass-effect">
        <!-- Header -->
        <div class="header">
            <div class="header-controls">
                <label>Author:</label>
                <div id="authorDisplayView" style="display: flex; align-items: center;">
                    <span id="authorNameDisplay" style="color: var(--accent-amber); font-weight: bold; font-family: var(--font-data);"></span>
                    <button class="btn btn-outline btn-sm" onclick="toggleAuthorEdit(true)" style="padding: 4px 8px; margin-left: 8px;">Change</button>
                </div>
                <div id="authorEditView" style="display: none;">
                    <input type="text" id="authorNameInput" placeholder="Enter name..." style="padding: 4px 8px; font-size: 14px; border-radius: 4px; border: 1px solid var(--accent-blue); background: var(--bg-dark); color: var(--text-primary);">
                    <button class="btn btn-success btn-sm" onclick="saveAuthorName()" style="padding: 4px 8px; margin-left: 8px;">Save</button>
                </div>
            </div>
            
            <!-- NEW: Right-side controls (Back to Dashboard and Guide) -->
            <div class="header-right-controls">
                <a href="index.html" class="btn btn-outline" title="Back to Dashboard">
                    <i data-lucide="home"></i>Dashboard
                </a>
                <button class="btn btn-outline" onclick="openGuideModal()">
                    <i data-lucide="help-circle"></i>Guide
                </button>
            </div>
            
            <h1><i data-lucide="droplets"></i>Drop Rate Editor<i data-lucide="droplets"></i></h1>
            <p>Zen & Excellent Option drop rate management</p>
        </div>
        
        <!-- Status Bar -->
        <div id="statusBar" class="status-bar"></div>
        
        <!-- Data Management (Cache) -->
        <div id="dataManagementSection" style="display: none; padding: 20px;">
            <div style="display: flex; justify-content: space-between; align-items: center;">
                <div>
                    <h3><i data-lucide="database"></i>Data Management</h3>
                    <p style="font-size: 14px; color: var(--text-secondary);">Your edits are saved locally. Server merging is handled on save.</p>
                </div>
                <button class="btn btn-danger" onclick="confirmClearCache()">
                    <i data-lucide="trash-2"></i> Clear Local Cache
                </button>
            </div>
        </div>
        
        <!-- Main Content (Editor Panel) -->
        <div class="main-content" id="mainContent" style="display: none;">
            <div class="editor-panel" style="padding: 25px;">
                <!-- Tab Navigation -->
                <div class="tab-nav">
                    <button class="tab-btn active" data-tab-name="zen" onclick="setActiveTab('zen')"><i data-lucide="gem" style="width: 16px;"></i> Zen Drop Rates</button>
                    <button class="tab-btn" data-tab-name="exel" onclick="setActiveTab('exel')"><i data-lucide="sparkles" style="width: 16px;"></i> Excellent Option Rates</button>
                </div>

                <div id="editorContent">
                    <div class="empty-state"><h3>Loading data...</h3><p>Ensure the back-end server is running.</p></div>
                </div>
            </div>
        </div>
    </div>
    
    <!-- Add/Edit Map Modal (Zen Drop Specific) -->
    <div class="modal" id="mapModal">
        <div class="modal-content glass-effect">
            <div class="modal-header">
                <h2 id="modalTitle">Add New Map Entry</h2>
                <button class="close-btn" onclick="closeModal('mapModal')"><i data-lucide="x"></i></button>
            </div>
            <form id="mapForm">
                <div class="modal-body">
                    <!-- This hidden input will store which category we're adding to -->
                    <input type="hidden" id="modalCategoryIndex" value="">
                    
                    <div class="form-grid">
                        <div class="form-group">
                            <label>Map Number *</label>
                            <input type="number" id="mapNumber" required min="0">
                        </div>
                        <div class="form-group">
                            <label>Disabled? *</label>
                            <select id="mapDisable" required>
                                <option value="0" ${zenDropData.globals.Enable === '0' ? 'selected' : ''}>No (Enabled)</option>
                                <option value="1" ${zenDropData.globals.Enable === '1' ? 'selected' : ''}>Yes (Disabled)</option>
                            </select>
                        </div>
                        <div class="form-group">
                            <label>Min Money Count *</label>
                            <input type="number" id="minMoney" value="10000" required min="0">
                        </div>
                        <div class="form-group">
                            <label>Max Money Count *</label>
                            <input type="number" id="maxMoney" value="30000" required min="0">
                        </div>
                        <div class="form-group full-width">
                            <label>Map Name Comment (Optional)</label>
                            <input type="text" id="mapComment" placeholder="e.g. Lorencia (Lv 10)">
                        </div>
                    </div>
                </div>
                <div class="modal-footer">
                    <button type="button" class="btn btn-outline" onclick="closeModal('mapModal')">Cancel</button>
                    <button type="submit" class="btn btn-success">Save</button>
                </div>
            </form>
        </div>
    </div>
    
    <!-- Guide Modal -->
    <div class="modal" id="guideModal">
        <div class="modal-content glass-effect">
            <div class="modal-header">
                <h2><i data-lucide="help-circle"></i> How to Use the Drop Rate Editor</h2>
                <button class="close-btn" onclick="closeModal('guideModal')"><i data-lucide="x"></i></button>
            </div>
            <div class="modal-body" id="guideContent">
                <h3>1. Zen Drop Rates</h3>
                <ul>
                    <li><strong>Global Settings:</strong> Control Zen multiplier and chance at the top.</li>
                    <li><strong>Map Lists:</strong> Edit Min/Max money for each map directly in the table.</li>
                    <li><strong>Zen Cap Warning:</strong> Rows turn <strong>amber</strong> if the potential max drop exceeds the 2.14B cap (based on the assumed monster level).</li>
                    <li>Use the <strong>Save Zen Changes</strong> button to save <code>ZenDrop.xml</code>.</li>
                </ul>
                
                <h3>2. Excellent Option Rates (Two Sub-Tabs)</h3>
                
                <h4>a. Option Count Rates</h4>
                <p>These rates determine how many Excellent Options (0 to 9) an item receives *if* it successfully drops with at least one Excellent Option. The rates for each row must sum up to exactly **10000**.</p>
                <ul>
                    <li>**Item Kind (View Items):** Use the <strong>View Items</strong> button to see the full list of items covered by the **Kind A** category (or **Kind B** sub-type for wings).</li>
                    <li>**Validation:** The 'Sum' column must equal exactly **10000** for the rates to be valid. Invalid rows will be highlighted in **red**.</li>
                </ul>
                
                <h4>b. Individual Option Chances</h4>
                <p>These rates define the probability (out of 10000) for a specific Excellent Option (e.g., Damage Increase, Life Increase) to be applied to an item, assuming the item is eligible for that option.</p>
                <ul>
                    <li>**Rate:** This value is independent of other options and determines its chance relative to 10000.</li>
                </ul>

                <h3>3. General Features</h3>
                 <ul>
                    <li><strong>Automatic Caching:</strong> All unsaved edits are saved to your browser cache.</li>
                    <li><strong>Undo/Redo:</strong> The <strong>Undo</strong> button supports the last 50 changes for the currently active tab's dataset.</li>
                 </ul>
            </div>
            <div class="modal-footer">
                <button class="btn btn-primary" onclick="closeModal('guideModal')">Got it!</button>
            </div>
        </div>
    </div>

    <script>
        // Full JavaScript for Zen Drop Editor (Now Drop Rate Editor)
        const SERVER_URL = 'http://149.202.139.156:3000'; // Make sure this is correct
        const CACHE_KEY = 'dropRateEditorCache';
        const ZEN_CAP = 2147483647; // Max signed 32-bit integer
        const RATE_SUM_REQUIRED = 10000; // The required sum for Excellent Drop Rates
        
        /**
         * Escapes special characters in a string for safe inclusion in XML.
         * @param {string} unsafe - The string to escape.
         * @returns {string} The escaped string.
         */
        function escapeXml(unsafe) {
            if (!unsafe) return '';
            // Escape the 5 reserved XML characters: <, >, &, ", '
            return unsafe.replace(/[<>&'"]/g, function (c) {
                switch (c) {
                    case '<': return '&lt;';
                    case '>': return '&gt;';
                    case '&': return '&amp;';
                    case "'": return '&apos;';
                    case '"': return '&quot;';
                    default: return c;
                }
            });
        }
        
        // --- Application State ---
        let zenDropData = {
            globals: {},
            categories: []
        };
        let originalZenXMLHeader = '<?xml version="1.0" encoding="utf-8"?>\n';
        
        let excellentDropRates = {
            common: [],
            wings: [],
        };
        
        // NEW: Excellent Option Definitions (Not drop rates, but the options themselves)
        let excellentOptions = {
            common: [],
            wings: []
        };

        // NEW: Map for Kind A Category Names (e.g., "0": "Swords", "6": "Helms")
        let itemCategories = {}; // { "0": "Swords" }
        // NEW: Item list structure to store all item details needed for lookup
        let allItemsByCat = {}; // { "0": [ {Name, Index, ItemKindA, ItemKindB}, ... ] }
        let flatAllItems = []; // NEW: Flat list of all items for robust filtering
        
        let originalExcellentXmlContent = ''; // NEW: Full XML content for merge
        
        // --- UI State ---
        let undoHistory = [];
        let isDataLoaded = false;
        let collapsedStates = {};
        let activeTab = 'zen'; // 'zen' or 'exel'
        let activeExelSubTab = 'count'; // 'count' or 'option' (NEW)
        // NEW: State for expanded detail rows
        let expandedExelRows = {}; // Key: 'type_index' -> boolean
        
        // Keys for the drop rate columns (for looping)
        const EXEL_RATE_KEYS = ['Zero', 'One', 'Two', 'Three', 'Four', 'Five', 'Six', 'Seven', 'Eight', 'Nine'];
        
        document.addEventListener('DOMContentLoaded', () => {
            lucide.createIcons();
            initializeAuthorLock(); 
        });

        /**
         * Displays a confirmation modal.
         * @param {string} title - The title of the modal.
         * @param {string} message - The message to display.
         * @param {function} onConfirm - The callback function to execute on confirmation.
         * @param {string} [buttonClass='btn-danger'] - The CSS class for the confirm button.
         */
        function confirmAction(title, message, onConfirm, buttonClass = 'btn-danger') {
            document.getElementById('confirmTitle').textContent = title;
            document.getElementById('confirmMessage').textContent = message;
            const confirmButton = document.getElementById('confirmButton');
            confirmButton.className = `btn ${buttonClass}`;
            confirmButton.onclick = () => {
                onConfirm();
                closeModal('confirmModal');
            };
            document.getElementById('confirmModal').classList.add('show');
            lucide.createIcons();
        }

        /**
         * Closes any modal by its ID.
         * @param {string} id - The ID of the modal to close.
         */
        function closeModal(id) {
            document.getElementById(id).classList.remove('show');
        }

        /** Closes the confirmation modal. */
        function closeConfirmModal() {
            closeModal('confirmModal');
        }
        
        /** Opens the guide modal. */
        function openGuideModal() {
            document.getElementById('guideModal').classList.add('show');
        }

        /** Initializes the author lock feature, prompting for a name if not set. */
        function initializeAuthorLock() {
            const authorName = localStorage.getItem('dropRateEditorAuthor'); 
            if (authorName && authorName.trim() !== '') {
                renderAuthorControls();
                loadData();
            } else {
                document.getElementById('authorModal').classList.add('show');
                lucide.createIcons();
            }
        }

        /** Saves the initial author name from the modal to local storage. */
        function saveInitialAuthorName() {
            const authorInput = document.getElementById('initialAuthorName');
            const authorName = authorInput.value.trim();
            if (authorName) {
                localStorage.setItem('dropRateEditorAuthor', authorName);
                closeModal('authorModal');
                renderAuthorControls();
                loadData();
            }
        }

        /** Renders the author name and controls in the header. */
        function renderAuthorControls() {
            const authorName = localStorage.getItem('dropRateEditorAuthor') || 'Unknown';
            document.getElementById('authorNameDisplay').textContent = authorName;
            document.getElementById('authorNameInput').value = authorName;
            toggleAuthorEdit(false);
            lucide.createIcons();
        }

        /**
         * Toggles the author display between view and edit modes.
         * @param {boolean} isEditing - True to switch to edit mode.
         */
        function toggleAuthorEdit(isEditing) {
            document.getElementById('authorDisplayView').style.display = isEditing ? 'none' : 'flex';
            document.getElementById('authorEditView').style.display = isEditing ? 'flex' : 'none';
            if (isEditing) document.getElementById('authorNameInput').focus();
        }

        /** Saves the updated author name from the edit input. */
        function saveAuthorName() {
            const authorName = document.getElementById('authorNameInput').value.trim();
            if (authorName) {
                localStorage.setItem('dropRateEditorAuthor', authorName);
                renderAuthorControls();
                const displayName = document.getElementById('authorNameDisplay');
                displayName.style.transition = 'none';
                displayName.style.backgroundColor = 'rgba(0, 255, 155, 0.2)';
                setTimeout(() => {
                    displayName.style.transition = 'background-color 0.5s ease';
                    displayName.style.backgroundColor = 'transparent';
                }, 100);
            } else {
                showStatus("Author name cannot be empty.", true);
            }
        }

        /**
         * Gets the author's name from local storage.
         * @returns {string} The author's name.
         */
        function getAuthorName() { return localStorage.getItem('dropRateEditorAuthor') || 'Unknown Editor'; }

        /**
         * Displays a status message bar.
         * @param {string} message The message to display.
         * @param {boolean} [isError=false] If true, shows an error style.
         * @param {boolean} [isWarning=false] If true, shows a warning style.
         * @param {boolean} [isInfo=false] If true, shows an info style.
         * @param {object[]} [controls=null] Optional buttons to add to the status bar.
         */
        function showStatus(message, isError = false, isWarning = false, isInfo = false, controls = null) {
            const statusBar = document.getElementById('statusBar');
            statusBar.innerHTML = '';
            const messageEl = document.createElement('span');
            messageEl.textContent = message;
            statusBar.appendChild(messageEl);
            let typeClass = 'status-bar-success';
            if (isError) typeClass = 'status-bar-error';
            else if (isWarning) typeClass = 'status-bar-warning';
            else if (isInfo) typeClass = 'status-bar-info';
            statusBar.className = `status-bar ${typeClass}`;
            statusBar.style.display = 'block';
            if (controls) {
                const controlsEl = document.createElement('div');
                controlsEl.className = 'status-bar-controls';
                controls.forEach(control => {
                    const btn = document.createElement('button');
                    btn.textContent = control.text;
                    btn.className = control.className;
                    btn.onclick = control.onClick;
                    controlsEl.appendChild(btn);
                    lucide.createIcons();
                });
                statusBar.appendChild(controlsEl);
            } else {
                setTimeout(() => { statusBar.style.display = 'none'; }, 5000);
            }
        }

        /** Displays a confirmation modal to clear all local data. */
        function confirmClearCache() {
            confirmAction(
                'Clear Local Cache?',
                'This will delete all your unsaved local changes and reload the latest data from the server. This action cannot be undone.',
                () => {
                    localStorage.removeItem(CACHE_KEY);
                    showStatus('Local cache cleared. Reloading from server...', false, false, true);
                    location.reload();
                }
            );
        }

        /** Saves the current editor state to local storage. */
        function saveToCache() {
            if (!isDataLoaded) return;
            const cache = {
                zenDropData: zenDropData,
                excellentDropRates: excellentDropRates, // Drop count rates
                excellentOptions: excellentOptions, // Individual option rates (NEW)
                // itemCategories and allItemsByCat are static reference data and are NOT cached
                undoHistory: undoHistory,
                activeTab: activeTab,
                activeExelSubTab: activeExelSubTab, // NEW: Save sub-tab state
                expandedExelRows: expandedExelRows, 
                timestamp: new Date().toISOString()
            };
            localStorage.setItem(CACHE_KEY, JSON.stringify(cache));
        }

        /**
         * Loads the editor state from local storage.
         * @returns {boolean} True if data was loaded from cache, false otherwise.
         */
        function loadFromCache() {
            try {
                const cache = JSON.parse(localStorage.getItem(CACHE_KEY));
                if (cache && cache.zenDropData) {
                    zenDropData = cache.zenDropData;
                    excellentDropRates = cache.excellentDropRates || { common: [], wings: [] };
                    excellentOptions = cache.excellentOptions || { common: [], wings: [] }; // NEW: Load options
                    undoHistory = cache.undoHistory || [];
                    activeTab = cache.activeTab || 'zen';
                    activeExelSubTab = cache.activeExelSubTab || 'count'; // NEW: Load sub-tab state
                    expandedExelRows = cache.expandedExelRows || {};
                    return true;
                }
            } catch (e) {
                console.error('Failed to parse cache:', e);
                localStorage.removeItem(CACHE_KEY);
            }
            return false;
        }

        /** Loads all initial data from the server and handles cache recovery. */
        async function loadData() {
            let serverData;
            try {
                // Fetch ZenDrop.xml, ItemExcellentOptions.xml, AND ItemList.xml
                const response = await fetch(`${SERVER_URL}/api/drop-data`); 
                if (!response.ok) throw new Error(`Server responded with status: ${response.status}`);
                serverData = await response.json();
            } catch (error) {
                console.error('Failed to load drop files from server:', error);
                showStatus(`âœ— Error: Could not load ZenDrop/ExcellentOptions XML from the server.`, true);
                const editorContent = document.getElementById('editorContent');
                if (editorContent) {
                    editorContent.innerHTML = `<div class="empty-state"><h3>Connection Failed</h3><p>Could not connect to the server at <strong>${SERVER_URL}</strong>.</p></div>`;
                }
                return;
            }
            
            // --- FIX: Aggressive Pre-parse cleanup for unescaped '&' (Defensive Measure) ---
            serverData.itemExcellentOptionsXml = serverData.itemExcellentOptionsXml.replace(/&(?!(amp;|quot;|apos;|lt;|gt;|#\d+;|#x[0-9a-fA-F]+;))/g, '&amp;');
            
            originalExcellentXmlContent = serverData.itemExcellentOptionsXml; // Store full XML for later merge
            
            // NEW: Parse Item List first, as it's static context data
            if (serverData.itemListXml) {
                parseItemCategoryList(serverData.itemListXml);
            } else {
                 console.warn("Item List XML not received from server. Category hints disabled.");
            }
            
            // Check for local cache
            const hasCache = loadFromCache();
            if (hasCache) {
                showStatus('You have unsaved changes from a previous session.', false, true, false, [
                    { text: 'Load My Changes', className: 'btn btn-warning btn-sm', onClick: () => {
                        finishLoading(true); // true = use cached data
                        showStatus('Loaded changes from local cache.', false, false, true);
                    }},
                    { text: 'Discard (Load from Server)', className: 'btn btn-outline btn-sm', onClick: () => {
                        localStorage.removeItem(CACHE_KEY);
                        parseZenDropXml(serverData.zenDropXml); 
                        parseExcellentDropXml(serverData.itemExcellentOptionsXml);
                        parseExcellentOptions(serverData.itemExcellentOptionsXml); // NEW: Parse option data
                        finishLoading(false); // false = use server data
                        expandedExelRows = {}; // Clear expanded state on discard
                        showStatus('Discarded local changes. Loaded fresh data from server.', false);
                    }}
                ]);
            } else {
                // No cache, just parse server data and finish
                parseZenDropXml(serverData.zenDropXml);
                parseExcellentDropXml(serverData.itemExcellentOptionsXml);
                parseExcellentOptions(serverData.itemExcellentOptionsXml); // NEW: Parse option data
                finishLoading(false);
            }
        }
        
        /**
         * Finalizes the data loading process, renders the UI, and handles cache state.
         * @param {boolean} usedCache - Indicates if the data was loaded from the local cache.
         */
        function finishLoading(usedCache) {
            isDataLoaded = true;
            document.getElementById('mainContent').style.display = 'grid';
            document.getElementById('dataManagementSection').style.display = 'block';
            
            if (zenDropData.categories.length > 0 || excellentDropRates.common.length > 0) {
                // Initial render will use the activeTab determined by cache (or 'zen' default)
                setActiveTab(activeTab); // Use setActiveTab to force render the correct panel
            } else {
                 document.getElementById('editorContent').innerHTML = `<div class="empty-state"><h3>No Drop Data Found</h3><p>ZenDrop.xml or ItemExcellentOptions.xml might be empty or corrupt.</p></div>`;
            }
            
            if (usedCache) saveToCache();
            lucide.createIcons();
        }

        /**
         * Parses the ZenDrop.xml content.
         * @param {string} xmlText - The XML content of ZenDrop.xml.
         */
        function parseZenDropXml(xmlText) {
            const headerMatch = xmlText.match(/^[\s\S]*?(?=<ZenDropSystem>)/i);
            originalZenXMLHeader = headerMatch ? headerMatch[0] : '<?xml version="1.0" encoding="utf-8"?>\n';
            
            const parser = new DOMParser();
            const xmlDoc = parser.parseFromString(xmlText, "text/xml");
            
            const root = xmlDoc.getElementsByTagName('ZenDropSystem')[0];
            if (!root) {
                console.error("Could not find <ZenDropSystem> root tag.");
                zenDropData = { globals: {}, categories: [] };
                return;
            }
            
            // 1. Parse Global Attributes
            zenDropData.globals = {
                Enable: root.getAttribute('Enable'),
                MultiplyByMonsterLevel: root.getAttribute('MultiplyByMonsterLevel'),
                MultiplyChanceRate: root.getAttribute('MultiplyChanceRate')
            };

            // 2. Parse Maps into Categories
            zenDropData.categories = [];
            let currentCategory = { name: "General", maps: [], isDefault: true };
            zenDropData.categories.push(currentCategory);
            
            let lastModComment = null;

            for (const childNode of root.childNodes) {
                if (childNode.nodeType === 8) { // Comment node
                    const commentText = childNode.nodeValue.trim();
                    
                    if (commentText.startsWith('=====')) {
                        // This is a category header
                        const categoryName = commentText.replace(/[=]/g, '').trim();
                        currentCategory = { name: categoryName, maps: [] };
                        zenDropData.categories.push(currentCategory);
                    }
                    else if (commentText.includes("Modified by:")) {
                        lastModComment = commentText;
                    }
                }
                
                if (childNode.nodeType === 1 && childNode.nodeName === 'Map') { // Element node
                    const mapData = {
                        Number: childNode.getAttribute('Number'),
                        MinMoneyCount: childNode.getAttribute('MinMoneyCount'),
                        MaxMoneyCount: childNode.getAttribute('MaxMoneyCount'),
                        Disable: childNode.getAttribute('Disable'),
                        comment: null,
                        modificationInfo: null
                    };

                    // 1. Assign modification comment
                    if (lastModComment) {
                         const authorMatch = lastModComment.match(/Modified by: (.*?) @/);
                         const timestampMatch = lastModComment.match(/@ (.*)/);
                         if (authorMatch && timestampMatch) {
                            mapData.modificationInfo = { author: authorMatch[1], timestamp: timestampMatch[1] };
                         }
                         lastModComment = null;
                    }
                    
                    // 2. Find map name comment (which comes *after* the tag)
                    let nextNode = childNode.nextSibling;
                    while (nextNode) {
                        if (nextNode.nodeType === 8) {
                            const commentText = nextNode.nodeValue.trim();
                             if (commentText && !commentText.includes("Modified by:") && !commentText.startsWith('=====')) {
                                mapData.comment = commentText;
                                break;
                             }
                        }
                        if (nextNode.nodeType === 1) break; // Stop at next element
                        nextNode = nextNode.nextSibling;
                    }
                    
                    currentCategory.maps.push(mapData);
                }
            }
            
            // Clean up: Remove "General" category if it's empty and we found other categories
            if (zenDropData.categories.length > 1 && zenDropData.categories[0].isDefault && zenDropData.categories[0].maps.length === 0) {
                zenDropData.categories.shift(); // Remove the empty "General" category
            }
        }
        
        /**
         * Parses the excellent option drop rate counts from ItemExcellentOptions.xml.
         * @param {string} xmlText - The XML content of ItemExcellentOptions.xml.
         */
        function parseExcellentDropXml(xmlText) {
            const parser = new DOMParser();
            const xmlDoc = parser.parseFromString(xmlText, "text/xml");
            
            const errorNode = xmlDoc.querySelector('parsererror');
            if (errorNode) {
                console.error("XML Parsing Error (ItemExcellentOptions):", errorNode.textContent);
            }
            
            excellentDropRates.common = parseDropRateSection(xmlDoc, 'OptionDropRate');
            excellentDropRates.wings = parseDropRateSection(xmlDoc, 'WingOptionDropRate');
        }

        /**
         * Parses a specific drop rate section (Common or Wings) from the XML document.
         * @param {XMLDocument} xmlDoc - The parsed XML document.
         * @param {string} tagName - The name of the root tag for the section (e.g., 'OptionDropRate').
         * @returns {object[]} An array of drop rate objects.
         */
        function parseDropRateSection(xmlDoc, tagName) {
            const list = [];
            const dropRateNode = xmlDoc.getElementsByTagName(tagName)[0];
            if (!dropRateNode) return list;

            for (const kindNode of dropRateNode.getElementsByTagName('Kind')) {
                const item = {
                    KindA: kindNode.getAttribute('KindA'),
                    KindB: kindNode.getAttribute('KindB') || null, 
                };
                
                let sum = 0;
                let isModified = false;
                
                EXEL_RATE_KEYS.forEach(key => {
                     // If attribute is missing, it defaults to '0' internally.
                     const value = kindNode.getAttribute(key) || '0';
                     item[key] = value;
                     sum += parseInt(value, 10) || 0;
                });
                
                item.currentSum = sum;
                item.isModified = isModified;
                list.push(item);
            }
            return list;
        }
        
        /**
         * Parses the ItemList.xml to build a comprehensive item data structure for lookups.
         * @param {string} xmlText - The XML content of ItemList.xml.
         */
        function parseItemCategoryList(xmlText) {
            const parser = new DOMParser();
            const xmlDoc = parser.parseFromString(xmlText, "text/xml");
            itemCategories = {};
            allItemsByCat = {};
            flatAllItems = [];
            
            for (let category of xmlDoc.getElementsByTagName('Category')) {
                // Use parseInt to normalize category index (e.g., "07" and "7" both becomes 7)
                const catIndex = category.getAttribute('Index'); 
                const catName = category.getAttribute('Name');
                
                if (catIndex !== null && catName !== null) {
                    itemCategories[catIndex] = catName; 
                    allItemsByCat[catIndex] = []; // Initialize array for all items in this category
                } else {
                    continue; // Skip invalid categories
                }
                
                for (let item of category.getElementsByTagName('Item')) {
                    const itemIndex = item.getAttribute('Index');
                    
                    // --- CRITICAL: Ensure KindA and KindB are read as strings, providing '-1' fallback if missing ---
                    const itemData = {
                        Name: item.getAttribute('Name'),
                        Index: itemIndex,
                        // Capture KindA and KindB attributes from the item tag itself
                        // NOTE: If KindA is missing, it defaults to -1, which is important for the filter below
                        ItemKindA: item.getAttribute('KindA') || '-1', 
                        ItemKindB: item.getAttribute('KindB') || '-1',
                        // The item's primary category is the Cat Index
                        Cat: catIndex
                    };
                    
                    allItemsByCat[catIndex].push(itemData);
                    flatAllItems.push(itemData);
                }
            }
            console.log(`[DEBUG] Parsed ${Object.keys(itemCategories).length} item categories and ${flatAllItems.length} total items for filtering.`);
        }

        /**
         * Parses the individual excellent option definitions from ItemExcellentOptions.xml.
         * @param {string} xmlText - The XML content of ItemExcellentOptions.xml.
         */
        function parseExcellentOptions(xmlText) {
            const parser = new DOMParser();
            const xmlDoc = parser.parseFromString(xmlText, "text/xml");
            
            excellentOptions.common = parseOptionSection(xmlDoc, 'Common');
            excellentOptions.wings = parseOptionSection(xmlDoc, 'Wings');
        }

        /**
         * Parses a specific section of excellent option definitions (Common or Wings).
         * @param {XMLDocument} xmlDoc - The parsed XML document.
         * @param {string} tagName - The name of the section tag ('Common' or 'Wings').
         * @returns {object[]} An array of option definition objects.
         */
        function parseOptionSection(xmlDoc, tagName) {
            const list = [];
            const sectionNode = xmlDoc.getElementsByTagName(tagName)[0];
            if (!sectionNode) return list;
            
            for (const optionNode of sectionNode.getElementsByTagName('Option')) {
                const item = {
                    ID: optionNode.getAttribute('ID'),
                    Number: optionNode.getAttribute('Number'),
                    Operator: optionNode.getAttribute('Operator'),
                    Value: optionNode.getAttribute('Value'),
                    FormulaID: optionNode.getAttribute('FormulaID'),
                    Rate: optionNode.getAttribute('Rate'),
                    // FIX: Must decode Name when reading from XML, as escapeXml encodes it on save
                    Name: optionNode.getAttribute('Name')
                        .replace(/&amp;/g, '&')
                        .replace(/&lt;/g, '<')
                        .replace(/&gt;/g, '>')
                        .replace(/&quot;/g, '"')
                        .replace(/&apos;/g, "'"),
                    // Only applicable to Common options
                    ItemKindA_1: optionNode.getAttribute('ItemKindA_1') || null,
                    ItemKindA_2: optionNode.getAttribute('ItemKindA_2') || null,
                    ItemKindA_3: optionNode.getAttribute('ItemKindA_3') || null,
                    ItemKindA_4: optionNode.getAttribute('ItemKindA_4') || null,
                    ItemKindA_5: optionNode.getAttribute('ItemKindA_5') || null,
                    ItemKindA_6: optionNode.getAttribute('ItemKindA_6') || null,
                    ItemKindA_7: optionNode.getAttribute('ItemKindA_7') || null,
                    // Only applicable to Wing options
                    ItemKindA: optionNode.getAttribute('ItemKindA') || null,
                    ItemKindB: optionNode.getAttribute('ItemKindB') || null,
                };
                item.isModified = false;
                list.push(item);
            }
            return list;
        }


        /** Pushes the current state of the active tab's data to the undo history. */
        function pushUndo() {
            if (undoHistory.length >= 50) undoHistory.shift();
            
            const stateToSave = activeTab === 'zen' 
                ? JSON.parse(JSON.stringify(zenDropData))
                : { 
                    rates: JSON.parse(JSON.stringify(excellentDropRates)),
                    options: JSON.parse(JSON.stringify(excellentOptions)), // NEW: Include Option definitions
                    subTab: activeExelSubTab // NEW
                  };
                
            undoHistory.push({ tab: activeTab, data: stateToSave });
            updateUndoButton();
            saveToCache();
        }

        /** Reverts the editor state to the last entry in the undo history. */
        function executeUndo() {
            if (undoHistory.length === 0) return;
            const lastState = undoHistory.pop();
            if (lastState) {
                if (lastState.tab === 'zen') {
                    zenDropData = lastState.data;
                } else if (lastState.tab === 'exel') {
                    excellentDropRates = lastState.data.rates;
                    excellentOptions = lastState.data.options; // NEW
                    activeExelSubTab = lastState.data.subTab; // NEW
                }
                setActiveTab(lastState.tab); 
            }
            updateUndoButton();
            saveToCache();
        }

        /** Updates the state and label of the undo button. */
        function updateUndoButton() {
            const btn = document.getElementById('undoBtn');
            if (btn) {
                btn.disabled = undoHistory.length === 0;
                btn.innerHTML = `<i data-lucide="undo-2"></i> ${undoHistory.length > 0 ? `Undo (${undoHistory.length})` : 'Undo'}`;
                lucide.createIcons();
            }
        }

        /**
         * Attaches author and timestamp information to a map object.
         * @param {object} map - The map data object.
         */
        function setModificationInfo(map) {
            map.modificationInfo = { author: getAuthorName(), timestamp: new Date().toLocaleString() };
        }
        
        document.addEventListener('keydown', (e) => { if (e.ctrlKey && e.key === 'z') { e.preventDefault(); executeUndo(); } });
        
        /**
         * Sets the active main tab ('zen' or 'exel') and re-renders the editor.
         * @param {string} tabName - The name of the tab to activate.
         */
        function setActiveTab(tabName) {
            activeTab = tabName;
            document.querySelectorAll('.tab-btn').forEach(btn => btn.classList.toggle('active', btn.dataset.tabName === tabName));
            renderEditor(); 
        }
        
        /**
         * Sets the active sub-tab for the excellent options panel and re-renders.
         * @param {string} subTabName - The name of the sub-tab ('count' or 'option').
         */
        function setActiveExelSubTab(subTabName) {
            activeExelSubTab = subTabName;
            renderEditor(); // Force re-render of the Exel panel content
        }

        /** Renders the main editor content based on the active tab. */
        function renderEditor() {
            // Re-render the main controls based on the active tab
            let htmlContent = '';
            
            let controlsHtml = `
                <div style="display: flex; justify-content: space-between; align-items: center; margin-bottom: 20px;">
                    <div>
                        <h2 style="color: var(--text-bright); margin-bottom: 5px;">${activeTab === 'zen' ? 'Zen Drop Rate Settings' : 'Excellent Drop Rate Tables'}</h2>
                        <p style="color: var(--text-secondary);">${activeTab === 'zen' ? 'Manage global multipliers and map-specific Zen drop amounts.' : 'C onfigure multi-option chance per ItemKindA/B and individual option rates.'}</p>
                    </div>
                    <div class="controls" style="display: flex; gap: 10px;">
                        <button id="undoBtn" class="btn btn-undo" onclick="executeUndo()" disabled><i data-lucide="undo-2"></i> Undo</button>
                        <button class="btn btn-success" onclick="${activeTab === 'zen' ? 'saveZenChangesToServer()' : 'saveExcellentOptionsToServer()'}" id="saveButton">
                            <i data-lucide="save"></i> Save ${activeTab === 'zen' ? 'Zen Changes' : 'Exel Changes'}
                        </button>
                    </div>
                </div>
            `;
            
            if (activeTab === 'zen') {
                htmlContent = renderZenDropPanel();
            } else {
                htmlContent = renderExcellentDropPanel();
            }
            
            document.getElementById('editorContent').innerHTML = controlsHtml + htmlContent;
            updateUndoButton();
            lucide.createIcons();
            
            if (activeTab === 'zen') {
                revalidateAllRows(); 
            } else if (activeExelSubTab === 'count') {
                revalidateAllExcellentDropRows(false); 
            }
        }
        
        /**
         * Toggles the visibility of a detail row in the excellent option count tables.
         * @param {string} type - The type of section ('common' or 'wings').
         * @param {number} index - The index of the row to toggle.
         */
        function toggleDetailRow(type, index) {
            const key = `${type}_${index}`;
            const detailRow = document.getElementById(`detail-row-${key}`);
            const btnIcon = document.getElementById(`detail-btn-icon-${key}`);
            
            if (!detailRow || !btnIcon) return;
            
            // Toggle state
            const isExpanded = expandedExelRows[key] === true;

            if (isExpanded) {
                delete expandedExelRows[key];
                detailRow.classList.add('detail-row-hidden');
                btnIcon.setAttribute('data-lucide', 'chevron-down');
            } else {
                expandedExelRows[key] = true;
                detailRow.classList.remove('detail-row-hidden');
                btnIcon.setAttribute('data-lucide', 'chevron-up');
            }
            lucide.createIcons();
            saveToCache(); // Persist expanded state
        }


        /**
         * Opens a modal to view all items that match a specific Kind A/B filter.
         * @param {string} type - The type of item group ('common' or 'wings').
         * @param {string|string[]} kindA - The Kind A filter value, or an array of values for individual options.
         * @param {string|null} kindB - The Kind B filter value (for wings).
         * @param {boolean} [isIndividualOption=false] - Flag to indicate if the filter logic is for an individual option.
         */
        function openItemViewModal(type, kindA, kindB, isIndividualOption = false) {
            const titleEl = document.getElementById('itemViewModalTitle');
            const descEl = document.getElementById('itemViewDescription');
            const listEl = document.getElementById('itemViewList');
            
            let filteredItems = flatAllItems; 
            
            let description = '';
            
            if (isIndividualOption && type === 'common') {
                // Individual Common Option: kindA is an array of up to 7 KindA filter values
                const kindAFilters = kindA; // kindA is passed as an array of ItemKindA values (strings)
                
                // Filter items where their ItemKindA matches ANY of the values in the kindAFilters array
                filteredItems = filteredItems.filter(item => kindAFilters.includes(item.ItemKindA));
                
                description = `This option applies to all items where the Item's internal **Kind A** attribute matches 
                                **${kindAFilters.join(', ')}**. 
                                If no items are found, check that the Kind A values are correctly set in <code>ItemList.xml</code>.`;
                titleEl.textContent = `Common Items: Kind A Filter(s) (${filteredItems.length} found)`;
                
            } else if (type === 'wings' && kindB && kindB !== '-1') {
                // Option Count or Individual Wing Option: filtered by KindA AND KindB
                const kindAFilter = kindA;
                const kindBFilter = kindB;
                
                filteredItems = filteredItems.filter(item => item.ItemKindA === kindAFilter && item.ItemKindB === kindBFilter);
                
                description = `This group targets items where the Item's internal **Kind A** is **${kindAFilter}** AND the internal **Kind B** is **${kindBFilter}**.`;
                titleEl.textContent = `Wing Items: Kind A ${kindAFilter}, Kind B ${kindBFilter} (${filteredItems.length} found)`;
            } else {
                // Option Count Common Item: filtered only by KindA
                const kindAFilter = kindA;
                filteredItems = filteredItems.filter(item => item.ItemKindA === kindAFilter);
                
                description = `This group applies to all items where the Item's internal **Kind A** attribute matches **${kindAFilter}**.`;
                titleEl.textContent = `Common Items: Kind A ${kindAFilter} (${filteredItems.length} found)`;
            }
            
            if (filteredItems.length === 0) {
                listEl.innerHTML = `
                    <div class="empty-state">
                        <p style="font-size: 16px; color: var(--accent-pink); margin-bottom: 10px;">
                            No items found matching the filter criteria.
                        </p>
                        <p>
                            Check the <strong>KindA</strong> and <strong>KindB</strong> attributes on the &lt;Item&gt; tags within your <code>ItemList.xml</code> file.
                        </p>
                    </div>
                `;
            } else {
                listEl.innerHTML = filteredItems.map(item => `
                    <li class="item-view-card">
                        <div class="item-view-name">${item.Name}</div>
                        <div class="item-view-id">Cat: ${item.Cat}, Index: ${item.Index}</div>
                        <div class="item-view-kind">
                           Kind A: <span style="color: var(--accent-amber);">${item.ItemKindA}</span>, 
                           Kind B: <span style="color: var(--accent-amber);">${item.ItemKindB}</span>
                        </div>
                    </li>
                `).join('');
            }

            descEl.innerHTML = description;
            document.getElementById('itemViewModal').classList.add('show');
            lucide.createIcons();
        }

        /**
         * Renders the HTML for the Zen Drop panel.
         * @returns {string} The HTML content for the Zen Drop panel.
         */
        function renderZenDropPanel() {
            let html = `
                <!-- Global Settings (ZEN) -->
                <div class="glass-effect global-settings-grid">
                    <div class="form-group">
                        <label>Zen Drop System</label>
                        <select class="form-group-input" onchange="updateGlobalValue('Enable', this.value)">
                            <option value="1" ${zenDropData.globals.Enable === '1' ? 'selected' : ''}>Enabled</option>
                            <option value="0" ${zenDropData.globals.Enable === '0' ? 'selected' : ''}>Disabled</option>
                        </select>
                    </div>
                    <div class="form-group">
                        <label>Multiply by Monster Level (Factor)</label>
                        <input type="number" step="0.1" class="form-group-input" value="${zenDropData.globals.MultiplyByMonsterLevel}" onchange="updateGlobalValue('MultiplyByMonsterLevel', this.value)">
                    </div>
                    <div class="form-group">
                        <label>Multiply Chance Rate (n / 10000)</label>
                        <input type="number" class="form-group-input" value="${zenDropData.globals.MultiplyChanceRate}" onchange="updateGlobalValue('MultiplyChanceRate', this.value)">
                    </div>
                    <div class="form-group">
                        <label>Bulk Increase (%)</label>
                        <div style="display: flex; gap: 10px;">
                            <input type="number" id="bulkPercent" placeholder="e.g. 10" style="flex-grow: 1;">
                            <button type="button" class="btn btn-warning" onclick="confirmBulkIncrease()" style="flex-shrink: 0; color: var(--bg-dark);">Apply %</button>
                        </div>
                    </div>
                    <div class="form-group">
                        <label>Highest Assumed Monster Level</label>
                        <input type="number" id="assumedLevelInput" value="400" style="flex-grow: 1;" title="Used to calculate Zen Cap warning" onchange="revalidateAllRows()">
                    </div>
                    <div class="form-group">
                        <label>Global Search</label>
                         <div class="search-bar" style="margin-left: 0;">
                            <input type="text" id="mapSearch" oninput="filterMaps()" placeholder="Search by map name or number...">
                        </div>
                    </div>
                </div>

                <!-- Map Tables (one per category) -->
                ${zenDropData.categories.map((category, categoryIndex) => renderCategoryTable(category, categoryIndex)).join('')}
            `;
            return html;
        }

        /**
         * Renders the HTML for the Excellent Options panel, including sub-tabs.
         * @returns {string} The HTML content for the Excellent Options panel.
         */
        function renderExcellentDropPanel() {
            let html = `<div id="exelDropPanelContent">`;
            
            // Sub-Tab Navigation
            html += `
                <div class="sub-tab-nav">
                    <button class="sub-tab-btn ${activeExelSubTab === 'count' ? 'active' : ''}" onclick="setActiveExelSubTab('count')">
                        <i data-lucide="list-ordered" style="width: 14px;"></i> Option Count Rates (0-9)
                    </button>
                    <button class="sub-tab-btn ${activeExelSubTab === 'option' ? 'active' : ''}" onclick="setActiveExelSubTab('option')">
                        <i data-lucide="zap" style="width: 14px;"></i> Individual Option Chances
                    </button>
                </div>
            `;
            
            html += `<div style="padding: 0 20px;">`;
            
            if (activeExelSubTab === 'count') {
                // 1. Common Excellent Options - Drop Count
                html += `<h3 style="margin-bottom: 10px; color: var(--text-bright);"><i data-lucide="shield"></i> Common Item Drop Counts (&lt;OptionDropRate&gt;)</h3>`;
                html += renderCommonDropTable(excellentDropRates.common);

                // 2. Wing Excellent Options - Drop Count
                html += `<h3 style="margin-bottom: 10px; margin-top: 30px; color: var(--text-bright);"><i data-lucide="feather"></i> Wing Item Drop Counts (&lt;WingOptionDropRate&gt;)</h3>`;
                html += renderWingDropTable(excellentDropRates.wings);
            } else if (activeExelSubTab === 'option') {
                // 3. Common Excellent Options - Individual Option Rate
                html += `<h3 style="margin-bottom: 10px; color: var(--text-bright);"><i data-lucide="zap"></i> Common Excellent Option Chances (&lt;Common&gt; Options)</h3>`;
                html += renderOptionRateTable(excellentOptions.common, 'common');

                // 4. Wing Excellent Options - Individual Option Rate
                html += `<h3 style="margin-bottom: 10px; margin-top: 30px; color: var(--text-bright);"><i data-lucide="feather"></i> Wing Excellent Option Chances (&lt;Wings&gt; Options)</h3>`;
                html += renderOptionRateTable(excellentOptions.wings, 'wings');
            }
            
            html += `</div></div>`; // Close padding div and exelDropPanelContent
            return html;
        }
        
        /**
         * Renders the table for individual excellent option rates.
         * @param {object[]} options - The array of option data for the section.
         * @param {string} type - The type of section ('common' or 'wings').
         * @returns {string} The HTML content for the table.
         */
        function renderOptionRateTable(options, type) {
            const tableTitle = "Rate controls the chance (n/10000) for this specific option to be selected from the available pool when an item drops with Excellent status.";
            
            let tableRows = options.map((option, index) => {
                const rowClass = option.isModified ? 'map-row-modified' : '';
                
                // Determine filter arguments and tooltip title
                let displayTitle = '';
                let filterArgs = [];

                if (type === 'common') {
                    const kinds = [];
                    // Collect all KindA filter values (up to 7)
                    for (let i = 1; i <= 7; i++) {
                        const kindVal = option[`ItemKindA_${i}`];
                        if (kindVal && kindVal !== '0' && kindVal !== '-1' && kindVal !== null) {
                            kinds.push(kindVal);
                        }
                    }
                    displayTitle = kinds.length > 0 ? `Filters: Kind A (${kinds.join(', ')})` : 'Filters: None (Applies to all/N/A)';
                    // The filter arguments for the common view modal is the type, the array of KindA values, and KindB null
                    filterArgs = [`'${type}'`, `[${kinds.map(k => `'${k}'`).join(', ')}]`, `null`, `true`];
                    
                } else { // Wings
                    const kindAValue = option.ItemKindA;
                    const kindBValue = option.ItemKindB;
                    displayTitle = `Filters: Kind A ${kindAValue}, Kind B ${kindBValue}`;
                    // The filter arguments for the wing view modal is the type, KindA, KindB, and isIndividualOption true
                    filterArgs = [`'${type}'`, `'${kindAValue}'`, `'${kindBValue}'`, `true`];
                }

                // Simplified button HTML - uses btn-sm and the new centered CSS
                const buttonHtml = `<button class="btn btn-sm btn-outline" 
                                    style="border-color: rgba(255, 193, 7, 0.4);"
                                    title="${displayTitle}"
                                    onclick="openItemViewModal(${filterArgs.join(', ')})">
                                    <i data-lucide="eye" style="width:14px; height:14px;"></i> View Items
                                  </button>`;


                return `
                    <tr class="${rowClass}" data-type="${type}" data-index="${index}">
                        <td style="font-weight: 600; font-family: var(--font-data);">${option.ID}</td>
                        <td class="option-name" title="ID: ${option.ID}, Number: ${option.Number}">${option.Name}</td>
                        <td class="kind-filter-cell" title="${displayTitle}">
                            ${buttonHtml}
                        </td>
                        <td style="font-family: var(--font-data);">
                            <input 
                                type="number" 
                                class="inline-input rate-input" 
                                value="${option.Rate}" 
                                min="0" 
                                max="10000"
                                title="${tableTitle}"
                                onchange="updateIndividualOptionRate(this, '${type}', ${index}, this.value)"
                            >
                        </td>
                        <td style="font-size: 12px; color: var(--text-secondary); text-align: center;">${option.Rate}/10000</td>
                    </tr>
                `;
            }).join('');

            return `
                <div class="rates-scroll-container">
                <div class="option-rate-table-container glass-effect" title="${tableTitle}">
                    <table class="option-rate-table">
                        <thead>
                            <tr>
                                <th style="min-width: 50px;">ID</th>
                                <th style="min-width: 350px;">Option Name</th>
                                <th style="min-width: 150px;">Applies To (Kind A/B Filter)</th>
                                <th style="min-width: 150px;">Rate (n/10000)</th>
                                <th style="min-width: 80px;">Ratio</th>
                            </tr>
                        </thead>
                        <tbody>
                            ${tableRows.length > 0 ? tableRows : `<tr><td colspan="5"><div class="empty-state">No options found for this section.</div></td></tr>`}
                        </tbody>
                    </table>
                </div>
                </div>
            `;
        }

        /**
         * Updates the rate of an individual excellent option.
         * @param {HTMLInputElement} inputElement - The input element that was changed.
         * @param {string} type - The type of section ('common' or 'wings').
         * @param {number} index - The index of the option to update.
         * @param {string} value - The new rate value.
         */
        function updateIndividualOptionRate(inputElement, type, index, value) {
            let dataList = excellentOptions[type];
            let option = dataList[index];
            const newValue = parseInt(value, 10);

            if (option.Rate !== value && !isNaN(newValue) && newValue >= 0) {
                pushUndo(); 
                
                option.Rate = newValue.toString();
                option.isModified = true;
                
                // Re-render row to update modified status color
                const row = document.querySelector(`tr[data-type="${type}"][data-index="${index}"]`);
                if (row) {
                    row.classList.add('map-row-modified');
                    // Manually update the Ratio cell
                    row.querySelector('td:last-child').textContent = `${newValue}/10000`;
                }

                saveToCache();
            } else if (isNaN(newValue) || newValue < 0) {
                 showStatus("Rate must be a non-negative number.", true);
                 inputElement.value = option.Rate; // Revert input value
            }
        }
        
        /**
         * Renders the table for common item excellent option counts.
         * @param {object[]} rates - The array of rate data for common items.
         * @returns {string} The HTML content for the table.
         */
        function renderCommonDropTable(rates) {
            const tableTitle = "Kind A corresponds to the item filter value (ItemKindA) used in ItemExcellentOptions.xml. The Sum must equal 10000.";
            // Keys for columns 1 through 5
            const columnHeaders = [1, 2, 3, 4, 5]; 
            
            let tableRows = rates.map((item, index) => {
                const mainRow = getExelDropRowHtml(item, index, 'common');
                return mainRow;
            }).join('');

            return `
                <div class="rates-scroll-container">
                <div class="drop-rate-table-container glass-effect" title="${tableTitle}">
                    <table>
                        <thead>
                            <tr>
                                <th style="min-width: 100px;">Item Kind A Filter</th>
                                <th title="This value must sum to exactly 10000 for the row to be valid.">Sum (Target: ${RATE_SUM_REQUIRED})</th>
                                ${columnHeaders.map((i) => `<th title="Chance (out of 10000) for the item to drop with exactly ${i} Excellent Options.">${i} Option Chance</th>`).join('')}
                                <th style="min-width: 120px;">Options 6-9</th>
                            </tr>
                        </thead>
                        <tbody>
                            ${tableRows}
                        </tbody>
                    </table>
                </div>
                </div>
            `;
        }
        
        /**
         * Renders the table for wing excellent option counts.
         * @param {object[]} rates - The array of rate data for wings.
         * @returns {string} The HTML content for the table.
         */
        function renderWingDropTable(rates) {
            const tableTitle = "Kind A/Kind B define the specific Wing Item Kind attributes used for filtering in ItemExcellentOptions.xml. The Sum must equal 10000.";
            const columnHeaders = [0, 1, 2, 3, 4, 5]; // 0 through 5
            
            let tableRows = rates.map((item, index) => {
                const mainRow = getExelDropRowHtml(item, index, 'wings');
                return mainRow;
            }).join('');

            return `
                <div class="rates-scroll-container">
                <div class="drop-rate-table-container glass-effect" title="${tableTitle}">
                    <table>
                        <thead>
                            <tr>
                                <th style="min-width: 100px;">Item Kind A Filter</th>
                                <th style="min-width: 100px;">Item Kind B Filter</th>
                                <th title="This value must sum to exactly 10000 for the row to be valid.">Sum (Target: ${RATE_SUM_REQUIRED})</th>
                                ${columnHeaders.map((i) => `<th title="Chance (out of 10000) for the item to drop with exactly ${i} Excellent Options.">${i} Option Chance</th>`).join('')}
                                <th style="min-width: 120px;">Options 6-9</th>
                            </tr>
                        </thead>
                        <tbody>
                            ${tableRows}
                        </tbody>
                    </table>
                </div>
                </div>
            `;
        }

        /**
         * Generates the HTML for a single row in an excellent option count table.
         * @param {object} item - The rate data for the row.
         * @param {number} index - The index of the row.
         * @param {string} type - The type of section ('common' or 'wings').
         * @returns {string} The HTML content for the table row and its detail row.
         */
        function getExelDropRowHtml(item, index, type) {
            const isInvalid = item.currentSum !== RATE_SUM_REQUIRED;
            const key = `${type}_${index}`;
            const isExpanded = expandedExelRows[key] === true;

            const visibleKeys = type === 'common' 
                ? EXEL_RATE_KEYS.slice(1, 6) 
                : EXEL_RATE_KEYS.slice(0, 6);
            
            const detailKeys = EXEL_RATE_KEYS.slice(6); // 6 through 9
            
            const baseCols = 3 + visibleKeys.length; 
            const wingsCols = baseCols + 1; 
            const colspan = type === 'wings' ? wingsCols : baseCols; 
            
            let rowClass = item.isModified ? 'map-row-modified' : '';
            if (isInvalid) rowClass += ' drop-rate-row-invalid';
            
            const rateTitle = 'The value represents the chance (out of 10000) for the item to drop with the corresponding number of Excellent Options.';

            const kindA = item.KindA;
            const kindB = item.KindB || '';
            const categoryName = itemCategories[kindA] || 'Unknown Category';
            
            // Build the Kind A cell with the button
            const kindACellHtml = `
                <td style="font-weight: 600; font-family: var(--font-data); padding-top: 10px; padding-bottom: 10px;" title="Filter applies to items where internal KindA attribute is ${kindA}">
                    ${kindA}
                    <button class="btn btn-sm btn-outline" 
                            style="margin-top: 5px; width: 100%; border-color: rgba(0, 170, 255, 0.4);"
                            onclick="openItemViewModal('${type}', '${kindA}', '${kindB}')">
                        <i data-lucide="eye" style="width:14px; height:14px;"></i> View Items
                    </button>
                </td>
            `;

            let kindBContent = '';
            if (type === 'wings') {
                 kindBContent = `<td style="font-weight: 600; font-family: var(--font-data);" title="Filter applies to items where internal KindB attribute is ${item.KindB}">
                    ${item.KindB}
                    <span style="font-size: 10px; color: var(--text-secondary); display: block; font-weight: normal;">Kind B Filter</span>
                 </td>`;
            }

            let html = `
                <tr class="${rowClass}" data-type="${type}" data-index="${index}" data-sum="${item.currentSum}">
                    ${kindACellHtml}
                    ${kindBContent}
                    <td class="rate-sum" style="font-weight: bold; color: ${isInvalid ? 'var(--accent-pink)' : 'var(--accent-green)'};">${item.currentSum.toLocaleString()}</td>
                    ${visibleKeys.map(key => `
                        <td>
                            <input 
                                type="number" 
                                class="inline-input rate-input ${isInvalid ? 'invalid-rate' : ''}" 
                                value="${item[key]}" 
                                min="0" 
                                data-rate-key="${key}" 
                                title="${rateTitle}"
                                onchange="updateExcellentDropRateValue(this, '${type}', ${index}, '${key}', this.value)"
                                oninput="validateExcellentDropRow('${type}', ${index})"
                            >
                        </td>
                    `).join('')}
                    
                    <td>
                        <button class="btn btn-sm btn-outline" onclick="toggleDetailRow('${type}', ${index})">
                            <i id="detail-btn-icon-${key}" data-lucide="${isExpanded ? 'chevron-up' : 'chevron-down'}"></i>
                            View/Edit
                        </button>
                    </td>
                </tr>
                
                <!-- Detail Row (The new collapsible row) -->
                <tr id="detail-row-${key}" class="${isExpanded ? '' : 'detail-row-hidden'}">
                    <td colspan="${colspan}" class="detail-cell">
                        <div class="detail-grid">
                            ${detailKeys.map((key, i) => {
                                const optionNumber = i + 6;
                                const rateTitleDetail = `Chance (out of 10000) for ${optionNumber} Excellent Options.`;
                                return `
                                    <div class="detail-group">
                                        <label>${optionNumber} Option Chance</label>
                                        <input 
                                            type="number" 
                                            class="inline-input rate-input ${isInvalid ? 'invalid-rate' : ''}" 
                                            value="${item[key]}" 
                                            min="0" 
                                            data-rate-key="${key}" 
                                            title="${rateTitleDetail}"
                                            onchange="updateExcellentDropRateValue(this, '${type}', ${index}, '${key}', this.value)"
                                            oninput="validateExcellentDropRow('${type}', ${index})"
                                        >
                                    </div>
                                `;
                            }).join('')}
                        </div>
                    </td>
                </tr>
            `;
            return html;
        }

        /**
         * Updates a value in an excellent option count rate row.
         * @param {HTMLInputElement} inputElement - The input element that was changed.
         * @param {string} type - The type of section ('common' or 'wings').
         * @param {number} index - The index of the row to update.
         * @param {string} key - The rate key to update (e.g., 'One', 'Two').
         * @param {string} value - The new value.
         */
        function updateExcellentDropRateValue(inputElement, type, index, key, value) {
            let dataList = excellentDropRates[type];
            let item = dataList[index];

            if (item[key] !== value) {
                pushUndo(); 
                
                item[key] = value;
                item.isModified = true;
                
                validateExcellentDropRow(type, index);
                
                saveToCache();
            }
        }
        
        /**
         * Validates the sum of rates for a row in the excellent option count table and updates its visual state.
         * @param {string} type - The type of section ('common' or 'wings').
         * @param {number} index - The index of the row to validate.
         */
        function validateExcellentDropRow(type, index) {
            const dataList = excellentDropRates[type];
            const item = dataList[index];
            const row = document.querySelector(`tr[data-type="${type}"][data-index="${index}"]`);
            if (!row) return; 

            let currentSum = 0;
            EXEL_RATE_KEYS.forEach(key => {
                const val = parseInt(item[key], 10);
                currentSum += isNaN(val) ? 0 : val;
            });
            
            item.currentSum = currentSum;
            const isInvalid = currentSum !== RATE_SUM_REQUIRED;
            
            const sumCell = row.querySelector('.rate-sum');
            if (sumCell) {
                sumCell.textContent = currentSum.toLocaleString();
                sumCell.style.color = isInvalid ? 'var(--accent-pink)' : 'var(--accent-green)';
            }
            
            row.classList.toggle('drop-rate-row-invalid', isInvalid);
            row.classList.toggle('map-row-modified', item.isModified && !isInvalid); 
            
            row.querySelectorAll('td .inline-input').forEach(input => {
                input.classList.toggle('invalid-rate', isInvalid);
            });
            
            const detailRow = document.getElementById(`detail-row-${type}_${index}`);
            if (detailRow) {
                 detailRow.querySelectorAll('input').forEach(input => {
                    input.classList.toggle('invalid-rate', isInvalid);
                });
            }

            const saveBtn = document.getElementById('saveButton');
            if (saveBtn) {
                const totalInvalidRows = [...excellentDropRates.common, ...excellentDropRates.wings].filter(i => i.currentSum !== RATE_SUM_REQUIRED).length;
                
                if (activeTab === 'exel' && activeExelSubTab === 'count') {
                    // Only disable save button on 'count' tab if count rates are invalid
                    saveBtn.disabled = totalInvalidRows > 0;
                } else if (activeTab === 'exel' && activeExelSubTab === 'option') {
                     // Keep save button disabled if any count rates are invalid, as this is critical path data.
                     saveBtn.disabled = totalInvalidRows > 0;
                } else {
                    saveBtn.disabled = false;
                }
            }
        }

        /** Revalidates all rows in the excellent option count tables. */
        function revalidateAllExcellentDropRows(forceReRender = false) {
            excellentDropRates.common.forEach((item, index) => {
                validateExcellentDropRow('common', index);
            });
            excellentDropRates.wings.forEach((item, index) => {
                validateExcellentDropRow('wings', index);
            });
            
            const saveBtn = document.getElementById('saveButton');
            if (saveBtn && activeTab === 'exel' && activeExelSubTab === 'count') {
                const totalInvalidRows = [...excellentDropRates.common, ...excellentDropRates.wings].filter(i => i.currentSum !== RATE_SUM_REQUIRED).length;
                saveBtn.disabled = totalInvalidRows > 0;
            }
        }
        
        /**
         * Renders a table for a specific category of Zen drop maps.
         * @param {object} category - The category object containing maps.
         * @param {number} categoryIndex - The index of the category.
         * @returns {string} The HTML content for the category table.
         */
        function renderCategoryTable(category, categoryIndex) {
            const isCollapsed = collapsedStates[category.name] || false;
            return `
                <div class="map-table-container glass-effect ${isCollapsed ? 'collapsed' : ''}" data-category-index="${categoryIndex}">
                    <div class="map-table-header" onclick="toggleCategory(this.parentElement, '${category.name}')">
                        <div style="display: flex; align-items: center; gap: 15px;">
                            <span class="toggle-icon"><i data-lucide="chevron-down"></i></span>
                            <h3><i data-lucide="map"></i> ${category.name} (${category.maps.length} maps)</h3>
                        </div>
                        <button class="btn btn-primary btn-sm" onclick="event.stopPropagation(); openAddModal(${categoryIndex})"><i data-lucide="plus"></i> Add Map</button>
                    </div>
                    <table>
                        <thead>
                            <tr>
                                <th>Map #</th>
                                <th>Map Name (Comment)</th>
                                <th>Min Money</th>
                                <th>Max Money</th>
                                <th>Disabled</th>
                                <th>Actions</th>
                            </tr>
                        </thead>
                        <tbody>
                            ${category.maps.map((map, mapIndex) => getMapRowHtml(map, categoryIndex, mapIndex)).join('')}
                        </tbody>
                    </table>
                </div>
            `;
        }

        /**
         * Generates the HTML for a single row in a Zen drop map table.
         * @param {object} map - The map data object.
         * @param {number} categoryIndex - The index of the category.
         * @param {number} mapIndex - The index of the map within the category.
         * @returns {string} The HTML content for the table row.
         */
        function getMapRowHtml(map, categoryIndex, mapIndex) {
            const { isInvalid, isWarning } = validateMap(map); 
            let rowClass = map.isNew ? 'map-row-new' : (map.isModified ? 'map-row-modified' : '');
            if (isInvalid) rowClass += ' map-row-empty';
            
            let modInfoHtml = '';
            if (map.modificationInfo) {
                modInfoHtml = `<div class="mod-info"><i data-lucide="info" style="width:12px; color: var(--accent-blue);"></i><span class="mod-info-text">Modified by: ${map.modificationInfo.author}<br>On: ${map.modificationInfo.timestamp}</span></div>`;
            }

            const invalidMin = (!map.MinMoneyCount || parseInt(map.MinMoneyCount) < 0) ? 'inline-input-invalid' : '';
            
            let maxClass = '';
            let maxTitle = '';
            const minVal = parseInt(map.MinMoneyCount);
            const maxVal = parseInt(map.MaxMoneyCount);
            
            if (isNaN(maxVal) || maxVal < 0 || maxVal < minVal) {
                maxClass = 'inline-input-invalid'; 
                maxTitle = 'Error: Max Money must be >= Min Money.';
            } else if (isWarning) {
                maxClass = 'inline-input-warning'; 
                const assumedLevel = parseInt(document.getElementById('assumedLevelInput')?.value || 400);
                const potentialMax = parseInt(map.MaxMoneyCount) * assumedLevel;
                maxTitle = `Warning: Potential max drop (~${potentialMax.toLocaleString()}) exceeds the 2.14B cap.`;
            }

            return `
                <tr data-map-indices="${categoryIndex},${mapIndex}" data-map-number="${map.Number}" data-map-name="${map.comment || ''}" class="${rowClass}">
                    <td style="font-family: var(--font-data); font-weight: 600;">${map.Number}</td>
                    <td class="map-name">${map.comment || 'N/A'}</td>
                    <td><input type="number" class="inline-input ${invalidMin}" value="${map.MinMoneyCount}" onchange="updateMapValue(${categoryIndex}, ${mapIndex}, 'MinMoneyCount', this.value, this)"></td>
                    <td><input type="number" class="inline-input ${maxClass}" value="${map.MaxMoneyCount}" title="${maxTitle}" onchange="updateMapValue(${categoryIndex}, ${mapIndex}, 'MaxMoneyCount', this.value, this)"></td>
                    <td>
                        <select class="inline-select" onchange="updateMapValue(${categoryIndex}, ${mapIndex}, 'Disable', this.value, this)">
                            <option value="0" ${map.Disable === '0' ? 'selected' : ''}>No</option>
                            <option value="1" ${map.Disable === '1' ? 'selected' : ''}>Yes</option>
                        </select>
                    </td>
                    <td style="white-space: nowrap; display: flex; align-items: center; gap: 4px;">
                        <button class="action-btn btn-delete" title="Delete Map" onclick="deleteMap(${categoryIndex}, ${mapIndex})"><i data-lucide="trash-2"></i></button>
                        ${modInfoHtml}
                    </td>
                </tr>
            `;
        }

        /**
         * Toggles the collapsed state of a Zen drop category table.
         * @param {HTMLElement} tableElement - The container element of the table.
         * @param {string} categoryName - The name of the category.
         */
        function toggleCategory(tableElement, categoryName) {
            const isCollapsed = tableElement.classList.toggle('collapsed');
            collapsedStates[categoryName] = isCollapsed;
        }

        /** Filters the Zen drop map tables based on the search input. */
        function filterMaps() {
            const searchTerm = document.getElementById('mapSearch').value.toLowerCase();
            document.querySelectorAll('.map-table-container').forEach(table => {
                let categoryHasVisibleRow = false;
                table.querySelectorAll('tbody tr[data-map-indices]').forEach(row => {
                    const mapNum = row.dataset.mapNumber.toLowerCase();
                    const mapName = row.dataset.mapName.toLowerCase();
                    const isVisible = (mapNum.includes(searchTerm) || mapName.includes(searchTerm));
                    row.style.display = isVisible ? '' : 'none';
                    if (isVisible) categoryHasVisibleRow = true;
                    // FIX: Re-enable the row if it's visible, otherwise it might stay hidden if display was set to none previously
                    row.style.display = isVisible ? '' : 'none';
                });
                table.style.display = categoryHasVisibleRow ? '' : 'none';
                
                if (searchTerm.length > 0 && categoryHasVisibleRow) {
                    table.classList.remove('collapsed');
                }
            });
        }
        
        /**
         * Updates a global Zen drop setting.
         * @param {string} field - The name of the global setting to update.
         * @param {string} value - The new value.
         */
        function updateGlobalValue(field, value) {
            if (zenDropData.globals[field] !== value) {
                pushUndo();
                zenDropData.globals[field] = value;
                saveToCache();
            }
        }

        /**
         * Updates a value for a specific map in the Zen drop table.
         * @param {number} categoryIndex - The index of the category.
         * @param {number} mapIndex - The index of the map.
         * @param {string} field - The property of the map to update.
         * @param {string} value - The new value.
         * @param {HTMLInputElement} inputElement - The input element that triggered the change.
         */
        function updateMapValue(categoryIndex, mapIndex, field, value, inputElement) {
            const map = zenDropData.categories[categoryIndex].maps[mapIndex];
            if (map[field] !== value) {
                if (!map.isNew) pushUndo();
                
                map[field] = value;
                
                if (!map.isNew) {
                    map.isModified = true;
                    setModificationInfo(map);
                }
                
                validateMapRow(categoryIndex, mapIndex, inputElement);
                
                saveToCache();
            }
        }
        
        /**
         * Validates a single map's data for errors and warnings.
         * @param {object} map - The map data object.
         * @returns {{isInvalid: boolean, isWarning: boolean}} An object indicating if the map data is invalid or has a warning.
         */
        function validateMap(map) {
            let isInvalid = false;
            let isWarning = false;
            const minVal = parseInt(map.MinMoneyCount);
            const maxVal = parseInt(map.MaxMoneyCount);
            
            if (isNaN(minVal) || minVal < 0 || isNaN(maxVal) || maxVal < 0 || maxVal < minVal) {
                isInvalid = true;
            }

            const assumedLevel = parseInt(document.getElementById('assumedLevelInput')?.value || 400);
            if (!isNaN(maxVal) && (maxVal * assumedLevel) > ZEN_CAP) {
                isWarning = true;
            }
            
            return { isInvalid, isWarning };
        }
        
        /**
         * Validates a row in the Zen drop map table and updates its visual state.
         * @param {number} categoryIndex - The index of the category.
         * @param {number} mapIndex - The index of the map.
         */
        function validateMapRow(categoryIndex, mapIndex, inputElement) {
            const row = document.querySelector(`tr[data-map-indices="${categoryIndex},${mapIndex}"]`);
            if (!row) return;

            const map = zenDropData.categories[categoryIndex].maps[mapIndex];
            const { isInvalid, isWarning } = validateMap(map);

            row.classList.toggle('map-row-empty', isInvalid);
            if (map.isModified) row.classList.add('map-row-modified');

            const minInput = row.querySelector('input[onchange*="MinMoneyCount"]');
            if (minInput) minInput.classList.toggle('inline-input-invalid', !map.MinMoneyCount || parseInt(map.MinMoneyCount) < 0);

            const maxInput = row.querySelector('input[onchange*="MaxMoneyCount"]');
            const minVal = parseInt(map.MinMoneyCount);
            const maxVal = parseInt(map.MaxMoneyCount);
            
            let maxClass = '';
            let maxTitle = '';
            if (isNaN(maxVal) || maxVal < 0 || maxVal < minVal) {
                maxClass = 'inline-input-invalid'; 
                maxTitle = 'Error: Max Money must be >= Min Money.';
            } else if (isWarning) {
                maxClass = 'inline-input-warning'; 
                const assumedLevel = parseInt(document.getElementById('assumedLevelInput')?.value || 400);
                const potentialMax = maxVal * assumedLevel;
                maxTitle = `Warning: Potential max drop (~${potentialMax.toLocaleString()}) exceeds the 2.14B cap.`;
            }
            if (maxInput) {
                maxInput.className = `inline-input ${maxClass}`;
                maxInput.title = maxTitle;
            }
        }

        /** Revalidates all rows in the Zen drop map tables. */
        function revalidateAllRows() {
            zenDropData.categories.forEach((category, categoryIndex) => {
                category.maps.forEach((map, mapIndex) => {
                    validateMapRow(categoryIndex, mapIndex);
                });
            });
        }

        /** Confirms and applies a bulk percentage increase to all Zen drop values. */
        function confirmBulkIncrease() {
            const input = document.getElementById('bulkPercent');
            const percent = parseFloat(input.value);

            if (isNaN(percent) || percent === 0) {
                showStatus('Please enter a valid, non-zero percentage to apply.', true);
                return;
            }
            
            const mapCount = zenDropData.categories.reduce((acc, cat) => acc + cat.maps.length, 0);

            confirmAction(
                `Increase all Zen values by ${percent}%?`,
                `This will modify Min/Max Zen for all ${mapCount} map entries. This action can be undone.`,
                () => {
                    applyBulkIncrease(percent);
                },
                'btn-warning' 
            );
        }

        /**
         * Applies a bulk percentage increase to all Min/Max Zen values.
         * @param {number} percent - The percentage to increase values by.
         */
        function applyBulkIncrease(percent) {
            pushUndo(); 
            
            let mapsModified = 0;
            const multiplier = 1 + (percent / 100);

            zenDropData.categories.forEach(category => {
                category.maps.forEach((map, mapIndex) => {
                    const oldMin = parseInt(map.MinMoneyCount, 10);
                    const oldMax = parseInt(map.MaxMoneyCount, 10);

                    if (!isNaN(oldMin) && !isNaN(oldMax)) {
                        map.MinMoneyCount = Math.round(oldMin * multiplier).toString();
                        map.MaxMoneyCount = Math.round(oldMax * multiplier).toString();
                        
                        if (!map.isNew) {
                            map.isModified = true;
                            setModificationInfo(map); 
                        }
                        validateMapRow(zenDropData.categories.findIndex(c => c === category), mapIndex);
                        mapsModified++;
                    }
                });
            });

            saveToCache();
            showStatus(`Successfully applied a ${percent}% increase to ${mapsModified} maps.`, false);
            document.getElementById('bulkPercent').value = ''; 
        }

        /**
         * Opens the modal to add a new map entry to a Zen drop category.
         * @param {number} categoryIndex - The index of the category to add to.
         */
        function openAddModal(categoryIndex) { 
            document.getElementById('modalTitle').textContent = 'Add New Map Entry';
            document.getElementById('mapForm').reset();
            document.getElementById('modalCategoryIndex').value = categoryIndex; 
            document.getElementById('mapModal').classList.add('show');
            lucide.createIcons();
        }
        
        /**
         * Deletes a map entry from a Zen drop category after confirmation.
         * @param {number} categoryIndex - The index of the category.
         * @param {number} mapIndex - The index of the map to delete.
         */
        function deleteMap(categoryIndex, mapIndex) {
            const map = zenDropData.categories[categoryIndex].maps[mapIndex];
            confirmAction(
                `Delete Map ${map.Number}?`,
                `Are you sure you want to delete Map ${map.Number} (${map.comment || 'N/A'})? This cannot be undone.`,
                () => {
                    pushUndo();
                    zenDropData.categories[categoryIndex].maps.splice(mapIndex, 1);
                    renderEditor(); 
                    saveToCache();
                }
            );
        }
        
        document.getElementById('mapForm').addEventListener('submit', function (e) {
            e.preventDefault();
            
            const categoryIndex = document.getElementById('modalCategoryIndex').value;
            if (categoryIndex === '') {
                showStatus('Error: Could not determine category to add to.', true);
                return;
            }
            
            const newMapData = {
                Number: document.getElementById('mapNumber').value,
                MinMoneyCount: document.getElementById('minMoney').value,
                MaxMoneyCount: document.getElementById('maxMoney').value,
                Disable: document.getElementById('mapDisable').value,
                comment: document.getElementById('mapComment').value.trim() || null,
                isNew: true
            };

            if (parseInt(newMapData.MaxMoneyCount) < parseInt(newMapData.MinMoneyCount)) {
                showStatus('Max Money must be greater than or equal to Min Money.', true);
                return;
            }

            pushUndo();
            setModificationInfo(newMapData);
            
            zenDropData.categories[categoryIndex].maps.push(newMapData);
            
            zenDropData.categories[categoryIndex].maps.sort((a, b) => parseInt(a.Number) - parseInt(b.Number));

            closeModal('mapModal');
            renderEditor(); 
            saveToCache();
        });
        
        /**
         * Generates the XML content for ZenDrop.xml from the current data.
         * @returns {{xml: string, invalidMapsSkipped: number}} An object containing the generated XML and the count of skipped invalid maps.
         */
        function generateZenDropXml() {
            let xml = originalZenXMLHeader;
            const globals = zenDropData.globals;
            xml += `<ZenDropSystem Enable="${globals.Enable}" MultiplyByMonsterLevel="${globals.MultiplyByMonsterLevel}" MultiplyChanceRate="${globals.MultiplyChanceRate}">\n\n`;

            let invalidMapsSkipped = 0;

            zenDropData.categories.forEach(category => {
                if (!category.isDefault) {
                     xml += `<!-- ============================= ${category.name} ============================= -->\n`;
                }
                
                category.maps.sort((a, b) => parseInt(a.Number) - parseInt(b.Number));

                category.maps.forEach(map => {
                    const { isInvalid } = validateMap(map);
                    if (isInvalid) {
                        invalidMapsSkipped++;
                        return; 
                    }
                    
                    if (map.modificationInfo) {
                        xml += `    <!-- Modified by: ${map.modificationInfo.author} @ ${map.modificationInfo.timestamp} -->\n`;
                    }

                    xml += `    <Map Number="${map.Number}" MinMoneyCount="${map.MinMoneyCount}" MaxMoneyCount="${map.MaxMoneyCount}" Disable="${map.Disable}" />`;
                    
                    if (map.comment) {
                        xml += ` <!-- ${map.comment} -->\n`;
                    } else {
                        xml += `\n`;
                    }
                });
                xml += `\n`; 
            });
            
            xml += '</ZenDropSystem>\n';
            return { xml, invalidMapsSkipped };
        }

        /** Saves the changes to ZenDrop.xml to the server. */
        async function saveZenChangesToServer() { 
            const saveButton = document.getElementById('saveButton'); 
            saveButton.disabled = true; 
            saveButton.innerHTML = `<i data-lucide="loader-2" class="spin"></i> Saving...`; 
            lucide.createIcons(); 
            document.querySelectorAll('.spin').forEach(el => el.animate([{ transform: 'rotate(0deg)' }, { transform: 'rotate(360deg)' }], { duration: 1000, iterations: Infinity }));
            
            const { xml, invalidMapsSkipped } = generateZenDropXml();
            
            try { 
                const response = await fetch(`${SERVER_URL}/api/save-zendrop`, {
                    method: 'POST', 
                    headers: { 'Content-Type': 'application/json' }, 
                    body: JSON.stringify({ newXmlContent: xml }), 
                }); 
                if (!response.ok) throw new Error(`Server responded with status: ${response.status}`); 
                
                let successMessage = 'âœ“ ZenDrop.xml saved successfully to the server!';
                if (invalidMapsSkipped > 0) {
                    successMessage += ` (${invalidMapsSkipped} invalid maps were skipped.)`;
                    showStatus(successMessage, false, true); 
                } else {
                    showStatus(successMessage, false);
                }
                
                localStorage.removeItem(CACHE_KEY);
                loadData(); 
                
            } catch (error) { 
                console.error('Failed to save ZenDrop.xml:', error); 
                showStatus(`âœ— Error: Could not save ZenDrop.xml. Your work is still cached locally.`, true); 
            } finally { 
                saveButton.disabled = false; 
                saveButton.innerHTML = `<i data-lucide="save"></i> Save Zen Changes`; 
                lucide.createIcons(); 
            } 
        }
        
        /**
         * Generates the XML content for the <Common> and <Wings> sections of excellent option definitions.
         * @returns {{commonXml: string, wingsXml: string}} An object containing the XML for both sections.
         */
        function generateOptionsXml() {
            let commonXml = '\t<Common> <!-- Common excellent options -->\n';
            excellentOptions.common.forEach(opt => {
                // ESCAPE opt.Name to prevent future XML parsing errors on reload if the name contains '&'
                const escapedName = escapeXml(opt.Name);
                commonXml += `\t\t<Option ID="${opt.ID}" Number="${opt.Number}" Operator="${opt.Operator}" Value="${opt.Value}" FormulaID="${opt.FormulaID}" ItemKindA_1="${opt.ItemKindA_1}" ItemKindA_2="${opt.ItemKindA_2}" ItemKindA_3="${opt.ItemKindA_3}" ItemKindA_4="${opt.ItemKindA_4}" ItemKindA_5="${opt.ItemKindA_5}" ItemKindA_6="${opt.ItemKindA_6}" ItemKindA_7="${opt.ItemKindA_7}" Rate="${opt.Rate}" Name="${escapedName}" />\n`;
            });
            commonXml += '\t</Common>\n';

            let wingsXml = '\t<Wings>\n';
            excellentOptions.wings.forEach(opt => {
                // ESCAPE opt.Name for Wing options as well
                const escapedName = escapeXml(opt.Name);
                wingsXml += `\t\t<Option ID="${opt.ID}" Number="${opt.Number}" Operator="${opt.Operator}" Value="${opt.Value}" FormulaID="${opt.FormulaID}" ItemKindA="${opt.ItemKindA}" ItemKindB="${opt.ItemKindB}" Rate="${opt.Rate}" Name="${escapedName}" />\n`;
            });
            wingsXml += '\t</Wings>\n';

            return { commonXml, wingsXml };
        }


        /**
         * Generates the complete XML content for ItemExcellentOptions.xml by merging updated sections.
         * @returns {{xml: string, invalidRatesSkipped: number}} An object containing the final XML and the count of skipped invalid rate groups.
         */
        function generateExcellentDropXml() {
            // 1. Generator for a drop rate section
            const generateRateSection = (rates, tagName) => {
                let xml = `<${tagName}>\n`;
                let invalidCount = 0;
                
                const shouldOmitZero = (tagName === 'OptionDropRate');
                
                rates.forEach(item => {
                    if (item.currentSum !== RATE_SUM_REQUIRED) { invalidCount++; return; }
                    
                    xml += `\t\t<Kind KindA="${item.KindA}" `;
                    if (tagName === 'WingOptionDropRate') {
                        xml += `KindB="${item.KindB}" `;
                    }

                    EXEL_RATE_KEYS.forEach(key => { 
                        const value = item[key];
                        
                        if (key === 'Zero') {
                            if (shouldOmitZero && parseInt(value, 10) === 0) {
                                // Omit the Zero attribute entirely if it's 0 for OptionDropRate
                                return; 
                            }
                            xml += `${key}="${value}" `;

                        } else {
                            xml += `${key}="${value}" `;
                        }
                    });
                    xml += '/>\n';
                });
                xml += `\t</${tagName}>`;
                return { xml, invalidCount };
            };
            
            // A. Generate Option Rate Counts (<OptionDropRate> / <WingOptionDropRate>)
            const commonRateResult = generateRateSection(excellentDropRates.common, 'OptionDropRate');
            const wingRateResult = generateRateSection(excellentDropRates.wings, 'WingOptionDropRate');
            const invalidRatesSkipped = commonRateResult.invalidCount + wingRateResult.invalidCount;
            
            // B. Generate Individual Option Definitions (<Common> / <Wings>)
            const optionDefinitionResult = generateOptionsXml();

            // C. Merge all sections back into the original XML template
            let finalXml = originalExcellentXmlContent;

            // Use regex to replace content between the tags, preserving the original outer structure/comments
            finalXml = finalXml.replace(/<OptionDropRate>[\s\S]*?<\/OptionDropRate>/, commonRateResult.xml);

            finalXml = finalXml.replace(/<WingOptionDropRate>[\s\S]*?<\/WingOptionDropRate>/, wingRateResult.xml);
            
            finalXml = finalXml.replace(/<Common>[\s\S]*?<\/Common>/, optionDefinitionResult.commonXml);

            finalXml = finalXml.replace(/<Wings>[\s\S]*?<\/Wings>/, optionDefinitionResult.wingsXml);


            return { xml: finalXml, invalidRatesSkipped: invalidRatesSkipped };
        }

        /** Saves the changes to ItemExcellentOptions.xml to the server. */
        async function saveExcellentOptionsToServer() {
            // Check again for invalid rows before starting the save process (Only count rates matter for this check)
            const totalInvalidCountRows = [...excellentDropRates.common, ...excellentDropRates.wings].filter(i => i.currentSum !== RATE_SUM_REQUIRED).length;
            if (totalInvalidCountRows > 0) {
                 showStatus(`Cannot save. Please fix the ${totalInvalidCountRows} invalid Option Count rate groups (Sum must be ${RATE_SUM_REQUIRED}).`, true);
                 return;
            }

            const saveButton = document.getElementById('saveButton'); 
            saveButton.disabled = true; 
            saveButton.innerHTML = `<i data-lucide="loader-2" class="spin"></i> Saving...`; 
            lucide.createIcons(); 
            document.querySelectorAll('.spin').forEach(el => el.animate([{ transform: 'rotate(0deg)' }, { transform: 'rotate(360deg)' }], { duration: 1000, iterations: Infinity }));

            const { xml, invalidRatesSkipped } = generateExcellentDropXml();

            try {
                 const response = await fetch(`${SERVER_URL}/api/save-excellent-options`, {
                    method: 'POST', 
                    headers: { 'Content-Type': 'application/json' }, 
                    body: JSON.stringify({ newXmlContent: xml }), 
                }); 
                if (!response.ok) throw new Error(`Server responded with status: ${response.status}`); 
                
                let successMessage = 'âœ“ ItemExcellentOptions.xml saved successfully!';
                if (invalidRatesSkipped > 0) {
                    successMessage += ` (${invalidRatesSkipped} invalid rate groups were skipped from Option Count tables.)`;
                    showStatus(successMessage, false, true); 
                } else {
                    showStatus(successMessage, false);
                }
                
                localStorage.removeItem(CACHE_KEY);
                loadData(); 

            } catch (error) {
                console.error('Failed to save ItemExcellentOptions.xml:', error);
                showStatus(`âœ— Error: Could not save ItemExcellentOptions.xml. Your work is still cached locally.`, true);
            } finally {
                saveButton.disabled = false; 
                saveButton.innerHTML = `<i data-lucide="save"></i> Save Exel Changes`; 
                lucide.createIcons(); 
            }
        }
    </script>
</body>
</html>