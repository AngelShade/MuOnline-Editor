<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Monster Spawn Editor (Web Edition)</title>

    <link rel="preconnect" href="https://fonts.googleapis.com">
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
    <link href="https://fonts.googleapis.com/css2?family=Fira+Code:wght@500&family=Inter:wght@400;600;700&display=swap" rel="stylesheet">

    <script src="https://unpkg.com/lucide@latest"></script>

    <style>
        :root {
            --bg-dark: #0a0f1e;
            --bg-glass: rgba(26, 34, 63, 0.6);
            --text-primary: #e0e0e0;
            --text-secondary: #a0a0c0;
            --text-bright: #ffffff;
            --font-ui: 'Inter', sans-serif;
            --font-data: 'Fira Code', monospace;
            
            --accent-blue: #00aaff;
            --accent-green: #00ff9b;
            --accent-amber: #ffc107;
            --accent-pink: #ff0055;
            --accent-purple: #6f42c1;
        }
        
        * { margin: 0; padding: 0; box-sizing: border-box; }
        
        body {
            font-family: var(--font-ui);
            background: linear-gradient(135deg, #1a223f 0%, var(--bg-dark) 100%);
            color: var(--text-primary);
            min-height: 100vh;
            padding: 20px;
        }
        
        .container {
            max-width: 1600px;
            margin: 0 auto;
            background: transparent;
            border-radius: 12px;
            padding: 30px;
            display: flex;
            flex-direction: column;
            gap: 20px;
        }

        .glass-effect {
            background: var(--bg-glass);
            backdrop-filter: blur(10px);
            border: 1px solid rgba(0, 170, 255, 0.2);
            border-radius: 12px;
            box-shadow: 0 8px 32px 0 rgba(0, 0, 0, 0.37);
        }
        
        .header { position: relative; padding: 30px; text-align: center; }
        .header .header-controls { position: absolute; top: 25px; left: 30px; display: flex; align-items: center; gap: 10px; background: rgba(0, 170, 255, 0.1); padding: 8px 12px; border-radius: 6px; }
        .header .header-controls label { font-weight: 600; font-size: 14px; }
        .header h1 { font-size: 28px; margin-bottom: 10px; color: var(--text-bright); display: flex; align-items: center; justify-content: center; gap: 15px; }
        .header p { color: var(--text-secondary); }
        
        /* Status Bar Variants */
        .status-bar { display: none; padding: 15px; border-radius: 8px; font-weight: 600; }
        .status-bar-success { background: rgba(0, 255, 155, 0.2); color: var(--accent-green); border: 1px solid var(--accent-green); }
        .status-bar-error { background: rgba(255, 0, 85, 0.2); color: var(--accent-pink); border: 1px solid var(--accent-pink); }
        .status-bar-warning { background: rgba(255, 193, 7, 0.2); color: var(--accent-amber); border: 1px solid var(--accent-amber); }
        .status-bar-info { background: rgba(0, 170, 255, 0.2); color: var(--accent-blue); border: 1px solid var(--accent-blue); }
        .status-bar-controls { display: flex; gap: 10px; margin-top: 10px; }
        
        .data-management-section h3 { display: flex; align-items: center; gap: 10px; margin-bottom: 15px; color: var(--text-bright); }
        .main-content { display: grid; grid-template-columns: 300px 1fr; gap: 20px; }
        .sidebar h3 { display: flex; align-items: center; gap: 10px; margin-bottom: 15px; color: var(--text-bright); }
        .map-list { max-height: 600px; overflow-y: auto; }
        .map-item { padding: 10px; margin-bottom: 5px; background: transparent; color: var(--text-secondary); border-radius: 6px; cursor: pointer; transition: all 0.2s; border-left: 3px solid transparent; font-size: 14px; }
        .map-item:hover { background: rgba(0, 170, 255, 0.1); color: var(--text-primary); border-left-color: var(--accent-blue); }
        .map-item.active { background: var(--accent-blue); color: var(--bg-dark); font-weight: 600; border-left-color: var(--accent-amber); }
        .map-item-number { font-weight: bold; margin-right: 8px; font-family: var(--font-data); }
        .search-bar input { width: 100%; padding: 12px; border: 1px solid rgba(0, 170, 255, 0.2); border-radius: 6px; font-size: 14px; background-color: rgba(0,0,0,0.3); color: var(--text-primary); }
        .search-bar input:focus { outline: none; border-color: var(--accent-blue); }

        .btn { padding: 10px 18px; border: none; border-radius: 6px; font-size: 14px; font-weight: 600; cursor: pointer; transition: all 0.3s; display: inline-flex; align-items: center; gap: 8px; }
        .btn:disabled { opacity: 0.4; cursor: not-allowed; }
        .btn-primary { background: var(--accent-blue); color: var(--bg-dark); }
        .btn-primary:hover:not(:disabled) { background: #fff; }
        .btn-success { background: var(--accent-green); color: var(--bg-dark); }
        .btn-success:hover:not(:disabled) { background: #fff; }
        .btn-danger { background: var(--accent-pink); color: #fff; }
        .btn-danger:hover:not(:disabled) { background: #fff; color: var(--accent-pink); }
        .btn-undo { background: var(--accent-purple); color: white; }
        .btn-undo:hover:not(:disabled) { background: #5a32a3; }
        .btn-outline { background: transparent; border: 1px solid rgba(0, 170, 255, 0.5); color: var(--accent-blue); }
        .btn-outline:hover { background: rgba(0, 170, 255, 0.1); }
        .btn-warning { background: var(--accent-amber); color: var(--bg-dark); }
        .btn-warning:hover:not(:disabled) { background: #fff; }
        
        .spawn-table { background: rgba(0,0,0,0.2); border-radius: 8px; overflow: hidden; margin-bottom: 20px; }
        .spawn-table h3 { cursor: pointer; user-select: none; display: flex !important; align-items: center; justify-content: space-between; transition: background-color 0.2s; padding: 15px; background: rgba(0,0,0,0.2); border-bottom: 1px solid rgba(0, 170, 255, 0.2); }
        .spawn-table h3:hover { background-color: rgba(0, 170, 255, 0.1) !important; }
        .toggle-icon { transition: transform 0.3s ease; }
        .spawn-table.collapsed .toggle-icon { transform: rotate(-90deg); }
        .spawn-table.collapsed table { display: none; }
        
        table { width: 100%; border-collapse: collapse; }
        th { background: rgba(0, 170, 255, 0.1); color: var(--text-bright); padding: 10px 12px; text-align: left; font-weight: 600; font-size: 13px; vertical-align: top; }
        td { padding: 8px 12px; border-bottom: 1px solid rgba(0, 170, 255, 0.1); vertical-align: middle; }
        tr:hover { background: rgba(0, 170, 255, 0.05); }

        .th-controls { display: flex; gap: 4px; justify-content: flex-start; margin-top: 5px; }
        .btn-th-action { padding: 2px 6px; font-size: 10px; font-weight: bold; background-color: transparent; border: 1px solid rgba(0, 170, 255, 0.3); color: var(--text-secondary); border-radius: 3px; cursor: pointer; transition: all 0.2s; font-family: var(--font-data); }
        .btn-th-action:hover { background-color: rgba(0, 170, 255, 0.1); border-color: var(--accent-blue); color: var(--text-bright); transform: translateY(-1px); }

        .th-input-group { display: flex; align-items: center; gap: 2px; }
        .th-input { width: 40px; text-align: center; background: rgba(0,0,0,0.3); border: 1px solid rgba(0, 170, 255, 0.3); color: var(--text-primary); border-radius: 3px; font-family: var(--font-data); font-size: 12px; padding: 3px; }
        .th-input-btn { padding: 1px 4px; font-size: 12px; line-height: 1; border: 1px solid rgba(0, 170, 255, 0.3); background: transparent; border-radius: 3px; cursor: pointer; color: var(--text-secondary); font-family: var(--font-data); }
        .th-input-btn:hover { background: rgba(0, 170, 255, 0.1); color: var(--text-bright); border-color: var(--accent-blue); }
        .btn-th-apply { padding: 3px 6px; font-size: 10px; font-weight: bold; background-color: transparent; border: 1px solid var(--accent-blue); color: var(--accent-blue); border-radius: 3px; cursor: pointer; transition: all 0.2s; font-family: var(--font-data); margin-left: 4px; }
        .btn-th-apply:hover { background-color: rgba(0, 170, 255, 0.1); color: var(--text-bright); }

        .spawn-row-new { background-color: rgba(0, 255, 155, 0.1) !important; }
        .spawn-row-modified { background-color: rgba(255, 193, 7, 0.1) !important; }
        .spawn-row-empty { background-color: rgba(255, 0, 85, 0.1) !important; }
        .spawn-row-selected { background-color: rgba(0, 170, 255, 0.15) !important; }

        .inline-input { width: 100%; padding: 4px 6px; border: 1px solid transparent; background: rgba(0,0,0,0.3); border-radius: 4px; font-family: var(--font-data); font-size: 14px; transition: all 0.2s; color: var(--text-primary); }
        .inline-input:hover:not(:disabled), .inline-input:focus:not(:disabled) { border-color: var(--accent-blue); background: var(--bg-dark); }
        .inline-input[disabled] { cursor: not-allowed; opacity: 0.6; background-color: rgba(0, 0, 0, 0.5); }
        .inline-input.coord { width: 45px; text-align: center; }
        .inline-input.inline-input-invalid { border-color: var(--accent-pink); background-color: rgba(255, 0, 85, 0.2); }
        
        input[type=number]::-webkit-inner-spin-button, input[type=number]::-webkit-outer-spin-button { -webkit-appearance: none; margin: 0; }
        input[type=number] { -moz-appearance: textfield; }
        
        .coord-group { display: flex; align-items: center; gap: 4px; }
        .inline-coord-btn { padding: 1px 5px; font-size: 11px; border: 1px solid rgba(0, 170, 255, 0.3); background: transparent; border-radius: 3px; cursor: pointer; color: var(--text-secondary); font-family: var(--font-data); transition: all 0.2s; }
        .inline-coord-btn:hover { background: rgba(0, 170, 255, 0.1); color: var(--text-bright); border-color: var(--accent-blue); }
        
        .monster-name { font-weight: 600; color: var(--text-primary); font-size: 14px; cursor: pointer; }
        .monster-name-cell { min-width: 220px; }
        
        .modal { display: none; position: fixed; top: 0; left: 0; width: 100%; height: 100%; background: rgba(0, 0, 0, 0.7); z-index: 1000; align-items: center; justify-content: center; }
        .modal.show { display: flex; }
        
        .modal-content { box-shadow: 0 8px 32px 0 rgba(0,0,0,0.5); color: var(--text-primary); max-width: 800px; width: 90%; max-height: 90vh; overflow-y: auto; }
        .modal-header { display: flex; justify-content: space-between; align-items: center; padding: 20px 25px; border-bottom: 1px solid rgba(0, 170, 255, 0.2); }
        .modal-header h2 { color: var(--text-bright); }
        .modal-body { padding: 25px; }
        .modal-footer { display: flex; gap: 10px; justify-content: flex-end; padding: 20px 25px; border-top: 1px solid rgba(0, 170, 255, 0.2); }
        .close-btn { color: var(--text-secondary); transition: all 0.2s; background: none; border: none; cursor: pointer;}
        .close-btn:hover { color: var(--text-bright); transform: rotate(90deg); }
        
        .form-grid { display: grid; grid-template-columns: 1fr 1fr; gap: 15px; }
        .form-group.full-width { grid-column: 1 / -1; }
        .form-group label { display: block; margin-bottom: 5px; font-weight: 600; color: var(--text-secondary); }
        .form-group input, .form-group select { width: 100%; padding: 10px; border: 1px solid rgba(0, 170, 255, 0.2); border-radius: 6px; font-size: 14px; background-color: rgba(0,0,0,0.3); color: var(--text-primary); }
        .form-group input:focus, .form-group select:focus { outline: none; border-color: var(--accent-blue); }
        .form-group input:disabled { cursor: not-allowed; opacity: 0.6; background-color: rgba(0, 0, 0, 0.5); }
        
        .input-group { display: flex; }
        .input-group input { border-top-right-radius: 0; border-bottom-right-radius: 0; flex: 1; }
        .input-group .btn-coord-preset { padding: 0 12px; background: rgba(0,0,0,0.2); color: var(--text-secondary); font-weight: 600; font-family: var(--font-data); font-size: 13px; border: 1px solid rgba(0, 170, 255, 0.2); border-left: none; cursor: pointer; transition: all 0.2s; }
        .input-group .btn-coord-preset:hover { background: rgba(0, 170, 255, 0.1); color: var(--text-bright); }
        .input-group .btn-coord-preset:last-child { border-top-right-radius: 6px; border-bottom-right-radius: 6px; }

        .monster-search { position: relative; }
        .monster-suggestions { background: var(--bg-dark); border: 1px solid var(--accent-blue); position: absolute; top: 100%; left: 0; right: 0; max-height: 200px; overflow-y: auto; z-index: 100; display: none; }
        .monster-suggestions.show { display: block; }
        .suggestion-item { padding: 10px; cursor: pointer; border-bottom: 1px solid rgba(0, 170, 255, 0.1); }
        .suggestion-item:hover { background: rgba(0, 170, 255, 0.1); }
        .suggestion-item-id { color: var(--accent-blue); font-family: var(--font-data); margin-right: 8px; }
        
        .action-btn { padding: 5px; border-radius: 4px; cursor: pointer; background: transparent; border: none; color: var(--text-secondary); }
        .action-btn:hover { color: var(--text-bright); }
        .btn-edit:hover { color: var(--accent-amber); }
        .btn-delete:hover { color: var(--accent-pink); }
        .btn-duplicate:hover { color: var(--accent-blue); }
        .empty-state { text-align: center; padding: 60px 20px; color: var(--text-secondary); }
        
        ::-webkit-scrollbar { width: 8px; }
        ::-webkit-scrollbar-track { background: transparent; }
        ::-webkit-scrollbar-thumb { background: var(--accent-blue); border-radius: 4px; }
        ::-webkit-scrollbar-thumb:hover { background: #fff; }

        .btn i, .action-btn i, h1 i, h3 i { width: 16px; height: 16px; stroke-width: 2.5; }
        .btn-sm i { width: 14px; height: 14px; }
        .action-btn i { width: 18px; height: 18px; }
        .header h1 i { width: 32px; height: 32px; color: var(--accent-blue); }

        #authorModal { z-index: 2000; }
        .author-modal-content { background: var(--bg-glass); backdrop-filter: blur(10px); border: 1px solid rgba(0, 170, 255, 0.2); box-shadow: 0 8px 32px 0 rgba(0,0,0,0.5); text-align: center; padding: 40px; border-radius: 12px; }
        .author-modal-content h2 { color: var(--text-bright); }
        .author-modal-content p { color: var(--text-secondary); }
        .author-modal-content input { background-color: rgba(0,0,0,0.3); color: var(--text-primary); border-color: rgba(0, 170, 255, 0.2); text-align: center; width: 100%; padding: 12px; font-size: 16px; border-radius: 6px; margin-bottom: 20px;}

        .spawn-table.editing-child-visible { overflow: visible; position: relative; z-index: 10; }
        
        .mod-info { position: relative; display: inline-flex; align-items: center; cursor: help; }
        .mod-info .mod-info-text { visibility: hidden; width: 250px; background-color: var(--bg-dark); color: #fff; text-align: center; border-radius: 6px; padding: 8px; position: absolute; z-index: 1; bottom: 150%; left: 50%; margin-left: -125px; opacity: 0; transition: opacity 0.3s; font-size: 12px; font-weight: normal; border: 1px solid var(--accent-blue); }
        .mod-info:hover .mod-info-text { visibility: visible; opacity: 1; }

        /* Guide Modal Styles */
        #guideContent { line-height: 1.7; color: var(--text-secondary); }
        #guideContent h3 { color: var(--text-bright); margin-top: 20px; margin-bottom: 10px; border-bottom: 1px solid rgba(0, 170, 255, 0.2); padding-bottom: 5px; }
        #guideContent h3:first-child { margin-top: 0; }
        #guideContent ul { list-style-position: inside; padding-left: 10px; }
        #guideContent li { margin-bottom: 10px; }
        #guideContent code { background-color: rgba(0,0,0,0.3); padding: 3px 6px; border-radius: 4px; font-family: var(--font-data); color: var(--accent-green); }
        #guideContent strong { color: var(--accent-amber); font-weight: 600; }
        
        /* Dropdown Button for "Add Spawn" */
        .dropdown { position: relative; display: inline-block; }
        .dropdown-content { display: none; position: absolute; background: var(--bg-glass); backdrop-filter: blur(10px); border: 1px solid rgba(0, 170, 255, 0.2); min-width: 200px; box-shadow: 0 8px 32px 0 rgba(0,0,0,0.37); z-index: 10; border-radius: 8px; overflow: hidden; right: 0; }
        .dropdown-content button { background: none; padding: 12px 16px; text-decoration: none; display: block; width: 100%; text-align: left; border: none; color: var(--text-primary); font-weight: 500; cursor: pointer; display: flex; align-items: center; gap: 10px; }
        .dropdown-content button:hover { background-color: rgba(0, 170, 255, 0.1); }
        .dropdown:hover .dropdown-content { display: block; }
        .dropdown:hover .btn-primary { background: #fff; }
        .dropdown .btn i { transition: transform 0.2s ease-in-out; }
        .dropdown:hover .btn i { transform: rotate(180deg); }
    </style>
</head>
<body>
    <div class="modal" id="authorModal"><div class="author-modal-content"><h2>Welcome</h2><p>Please enter your name to track your changes.</p><input type="text" id="initialAuthorName" placeholder="Your Name..." oninput="this.value ? document.getElementById('saveInitialAuthorBtn').disabled=false : document.getElementById('saveInitialAuthorBtn').disabled=true"><button id="saveInitialAuthorBtn" class="btn btn-primary" onclick="saveInitialAuthorName()" disabled>Save & Begin</button></div></div>
    
    <div class="modal" id="confirmModal">
        <div class="modal-content glass-effect" style="max-width: 500px;">
            <div class="modal-header">
                <h2 id="confirmTitle">Are you sure?</h2>
                <button class="close-btn" onclick="closeConfirmModal()"><i data-lucide="x"></i></button>
            </div>
            <div class="modal-body">
                <p id="confirmMessage" style="color: var(--text-secondary); line-height: 1.6;">This action cannot be undone.</p>
            </div>
            <div class="modal-footer">
                <button class="btn btn-outline" onclick="closeConfirmModal()">Cancel</button>
                <button id="confirmButton" class="btn btn-danger">Confirm</button>
            </div>
        </div>
    </div>
    
    <div class="container glass-effect">
        <div class="header">
            <div class="header-controls">
                <label>Author:</label>
                <div id="authorDisplayView" style="display: flex; align-items: center;">
                    <span id="authorNameDisplay" style="color: var(--accent-amber); font-weight: bold; font-family: var(--font-data);"></span>
                    <button class="btn btn-outline btn-sm" onclick="toggleAuthorEdit(true)" style="padding: 4px 8px; margin-left: 8px;">Change</button>
                </div>
                <div id="authorEditView" style="display: none;">
                    <input type="text" id="authorNameInput" placeholder="Enter name..." style="padding: 4px 8px; font-size: 14px; border-radius: 4px; border: 1px solid var(--accent-blue); background: var(--bg-dark); color: var(--text-primary);">
                    <button class="btn btn-success btn-sm" onclick="saveAuthorName()" style="padding: 4px 8px; margin-left: 8px;">Save</button>
                </div>
            </div>
            <h1><i data-lucide="siren"></i>MU Spawn Editor<i data-lucide="siren"></i></h1>
            <p>Data-centric interface for managing monster spawns</p>
            <div class="header-right-controls" style="position: absolute; top: 25px; right: 30px; display: flex; gap: 10px;">
                <a href="index.html" class="btn btn-outline" title="Back to Dashboard">
                    <i data-lucide="home"></i>Dashboard
                </a>
                <button class="btn btn-outline" onclick="openGuideModal()"><i data-lucide="help-circle"></i>Guide</button>
            </div>
            </div>
        
        <div id="statusBar" class="status-bar"></div>
        
        <div id="dataManagementSection" class="glass-effect" style="display: none; padding: 20px;">
            <div style="display: flex; justify-content: space-between; align-items: center;">
                <div>
                    <h3><i data-lucide="database"></i>Data Management</h3>
                    <p style="font-size: 14px; color: var(--text-secondary);">Server-side merging is handled automatically on save.</p>
                </div>
                <button class="btn btn-danger" onclick="confirmClearCache()">
                    <i data-lucide="trash-2"></i> Clear Local Cache
                </button>
            </div>
        </div>
        
        <div class="main-content" id="mainContent" style="display: none;">
            <div class="sidebar glass-effect" style="padding: 20px;">
                <h3><i data-lucide="map"></i>Maps</h3>
                <div class="search-bar" style="margin-bottom: 15px;"><input type="text" id="mapSearch" oninput="filterMaps()" placeholder="Search maps..."></div>
                <div class="map-list" id="mapList"></div>
            </div>
            <div class="editor-panel glass-effect" style="padding: 25px;">
                <div id="editorContent"><div class="empty-state"><h3>Loading data...</h3><p>Ensure the back-end server is running.</p></div></div>
            </div>
        </div>
    </div>
    
    <div class="modal" id="spawnModal">
        <div class="modal-content glass-effect">
            <div class="modal-header">
                <h2 id="modalTitle"></h2>
                <button class="close-btn" onclick="closeModal()"><i data-lucide="x"></i></button>
            </div>
            <form id="spawnForm">
                <div class="modal-body">
                    <div class="form-grid">
                        <div class="form-group full-width monster-search">
                            <label>Monster * <span id="npcWarning" style="color: var(--accent-pink); font-size: 12px; display: none;">(NPCs/Traps only)</span></label>
                            <input type="text" id="monsterSearch" autocomplete="off" required>
                            <input type="hidden" id="monsterIndex">
                            <div class="monster-suggestions" id="monsterSuggestions"></div>
                        </div>
                        <div class="form-group">
                            <label>Spawn Type *</label>
                            <select id="spawnType" required onchange="updateSpawnTypeRestrictions()">
                                <option value="0">NPC/Traps</option>
                                <option value="1">Multiple Monsters</option>
                                <option value="2">Single Monster</option>
                                <option value="3">Multiple Elemental</option>
                                <option value="4">Single Elemental</option>
                            </select>
                        </div>
                        <div class="form-group">
                            <label>Count</label>
                            <input type="number" id="spawnCount" value="1" min="0">
                        </div>
                        <div class="form-group"><label>Start X *</label><input type="number" id="startX" required min="0"></div>
                        <div class="form-group"><label>Start Y *</label><input type="number" id="startY" required min="0"></div>
                        <div class="form-group"><label>End X</label><input type="number" id="endX" value="0" min="0"></div>
                        <div class="form-group">
                            <label>End Y</label>
                            <div class="input-group">
                                <input type="number" id="endY" value="0" min="0">
                                <button type="button" class="btn-coord-preset" onclick="setEndCoords(3, 'modal')">+3</button>
                                <button type="button" class="btn-coord-preset" onclick="setEndCoords(4, 'modal')">+4</button>
                                <button type="button" class="btn-coord-preset" onclick="setEndCoords(5, 'modal')">+5</button>
                            </div>
                        </div>
                        <div class="form-group"><label>Distance</label><input type="number" id="distance" value="0" min="0"></div>
                        <div class="form-group"><label>Direction</label><input type="number" id="dir" value="-1" min="-1" max="7"></div>
                        <div class="form-group"><label>Element</label><input type="number" id="element" value="0" min="0" max="5"></div>
                        <div class="form-group full-width" id="npcFunctionGroup" style="display: none;"><label>NPC Function</label><input type="text" id="npcFunction" placeholder="None"></div>
                    </div>
                </div>
                <div class="modal-footer">
                    <button type="button" class="btn btn-outline" onclick="closeModal()">Cancel</button>
                    <button type="submit" class="btn btn-success">Save</button>
                </div>
            </form>
        </div>
    </div>
    
    <div class="modal" id="guideModal">
        <div class="modal-content glass-effect">
            <div class="modal-header">
                <h2><i data-lucide="help-circle"></i> How to Use the Spawn Editor</h2>
                <button class="close-btn" onclick="closeGuideModal()"><i data-lucide="x"></i></button>
            </div>
            <div class="modal-body" id="guideContent">
                <h3>1. Getting Started</h3>
                <ul>
                    <li><strong>Set Your Author Name:</strong> The first time you visit, you'll be required to enter a name. This name is saved in your browser and will be attached to all changes you make. You can change it later using the <code>Change</code> button in the top-left.</li>
                    <li><strong>Loading:</strong> The editor automatically loads the latest files from the server when you open the page.</li>
                </ul>

                <h3>2. Data Caching & Recovery</h3>
                <ul>
                    <li><strong>Automatic Caching:</strong> All your edits are automatically saved to your browser's local storage. If you refresh or close the tab, your work is not lost.</li>
                    <li><strong>Session Recovery:</strong> If the app detects unsaved changes from a previous session, it will notify you with a yellow bar at the top. You can choose to <strong>Load My Changes</strong> or <strong>Discard</strong> them to start fresh from the server.</li>
                    <li><strong>Clear Cache:</strong> If you ever get into a bad state, you can use the <strong>Clear Local Cache</strong> button in the Data Management section to force a fresh load from the server (you will be asked to confirm).</li>
                </ul>

                <h3>3. Editing & Tracking Changes</h3>
                <ul>
                    <li>When you edit, add, or duplicate a spawn, it will be tagged with your author name and the current time. This is saved as a comment in the XML file.</li>
                    <li>Modified rows are highlighted: <strong>amber</strong> for edits, <strong>green</strong> for new spawns.</li>
                    <li>An info icon <i data-lucide="info" style="width:14px; height: 14px; display: inline-block; vertical-align: middle;"></i> will appear next to a modified monster name. Hover over it to see who made the change and when.</li>
                </ul>

                <h3>4. Collaboration & Merging</h3>
                 <ul>
                    <li><strong>Smart Saving:</strong> The server is designed to handle multiple users. When you click <code>Save Changes</code>, the server intelligently merges your edits with any changes made by other users, preventing data loss.</li>
                </ul>

                <h3>5. Workflow Features</h3>
                <ul>
                    <li><strong>Inline Editing:</strong> Click directly on any value in the table (monster name, coordinates, count, etc.) to edit it instantly. For monster names, a search box will appear.</li>
                    <li>**NPC Function Handling:** The NpcFunc is **not** visible in the table. It is automatically pulled from the Monster List data when an NPC is selected and saved with the spawn.</li>
                    <li><strong>Data Validation:</strong> Required fields (Monster, StartX, StartY, Count) cannot be empty. If you clear them, the input and the row will turn red to indicate an error. Invalid spawns will be skipped during save.</li>
                    <li><strong>Bulk Actions:</strong> Use the small buttons in the table headers (e.g., <code>+3</code>, <code>5</code>, <code>10</code>) to apply a value to all spawns in that entire category at once.</li>
                    <li><strong>Copy, Paste & Delete:</strong> Use the checkboxes to select multiple spawns within a single category. The <code>Copy</code> and <code>Delete Selected</code> buttons in the category header will become active. You can then paste the copied spawns into another category of the same type.</li>
                    <li><strong>Note:</strong> You cannot paste regular monsters into NPC/Trap groups, or vice-versa.</li>
                </ul>

                <h3>6. Saving Your Work</h3>
                 <ul>
                    <li>To finalize your work, click the <strong><i data-lucide="save" style="width:14px; height: 14px; display: inline-block; vertical-align: middle;"></i> Save Changes</strong> button. This sends your edits to the server, creates a backup, merges them safely, and saves them to the master file.</li>
                </ul>
            </div>
            <div class="modal-footer">
                <button class="btn btn-primary" onclick="closeGuideModal()">Got it!</button>
            </div>
        </div>
    </div>

    <script>
        // Full, enhanced JavaScript block
        const SERVER_URL = 'http://149.202.139.156:3000'; 
        const CACHE_KEY = 'spawnEditorCache';
        
        // --- Application State ---
        let monsterList = {};
        let spawnData = {};
        let currentMap = null;
        let originalXMLHeader = '<?xml version="1.0" encoding="utf-8"?>\n';
        
        // --- UI State ---
        let editingSpawnIndex = null;
        let addingToSpotIndex = null;
        let sortDirections = {};
        let collapsedStates = {};
        let undoHistory = [];
        let activeInlineEditor = null;
        let selectedSpawns = [];
        let spawnClipboard = [];
        let clipboardSourceType = null;
        let isDataLoaded = false;

        
        document.addEventListener('DOMContentLoaded', () => {
            lucide.createIcons();
            initializeAuthorLock();
        });

        // --- Confirmation Modal Logic ---
        function confirmAction(title, message, onConfirm, buttonClass = 'btn-danger') {
            document.getElementById('confirmTitle').textContent = title;
            document.getElementById('confirmMessage').textContent = message;
            const confirmButton = document.getElementById('confirmButton');
            confirmButton.className = `btn ${buttonClass}`;
            confirmButton.onclick = () => {
                onConfirm();
                closeConfirmModal();
            };
            document.getElementById('confirmModal').classList.add('show');
            lucide.createIcons();
        }

        function closeConfirmModal() {
            document.getElementById('confirmModal').classList.remove('show');
        }

        // --- Author Logic ---
        function initializeAuthorLock() {
            const authorName = localStorage.getItem('spawnEditorAuthor');
            if (authorName && authorName.trim() !== '') {
                renderAuthorControls();
                loadData();
            } else {
                document.getElementById('authorModal').classList.add('show');
                lucide.createIcons();
            }
        }

        function saveInitialAuthorName() {
            const authorInput = document.getElementById('initialAuthorName');
            const authorName = authorInput.value.trim();
            if (authorName) {
                localStorage.setItem('spawnEditorAuthor', authorName);
                document.getElementById('authorModal').classList.remove('show');
                renderAuthorControls();
                loadData();
            }
        }

        function renderAuthorControls() {
            const authorName = localStorage.getItem('spawnEditorAuthor') || 'Unknown';
            document.getElementById('authorNameDisplay').textContent = authorName;
            document.getElementById('authorNameInput').value = authorName;
            toggleAuthorEdit(false);
            lucide.createIcons();
        }

        function toggleAuthorEdit(isEditing) {
            document.getElementById('authorDisplayView').style.display = isEditing ? 'none' : 'flex';
            document.getElementById('authorEditView').style.display = isEditing ? 'flex' : 'none';
            if (isEditing) {
                document.getElementById('authorNameInput').focus();
            }
        }

        function saveAuthorName() {
            const authorName = document.getElementById('authorNameInput').value.trim();
            if (authorName) {
                localStorage.setItem('spawnEditorAuthor', authorName);
                renderAuthorControls();
                const displayName = document.getElementById('authorNameDisplay');
                displayName.style.transition = 'none';
                displayName.style.backgroundColor = 'rgba(0, 255, 155, 0.2)';
                setTimeout(() => {
                    displayName.style.transition = 'background-color 0.5s ease';
                    displayName.style.backgroundColor = 'transparent';
                }, 100);
            } else {
                showStatus("Author name cannot be empty.", true);
            }
        }

        function getAuthorName() { return localStorage.getItem('spawnEditorAuthor') || 'Unknown Editor'; }

        // --- Status & Cache Logic ---
        function showStatus(message, isError = false, isWarning = false, isInfo = false, controls = null) {
            const statusBar = document.getElementById('statusBar');
            statusBar.innerHTML = ''; // Clear previous content
            
            const messageEl = document.createElement('span');
            messageEl.textContent = message;
            statusBar.appendChild(messageEl);

            let typeClass = 'status-bar-success';
            if (isError) typeClass = 'status-bar-error';
            else if (isWarning) typeClass = 'status-bar-warning';
            else if (isInfo) typeClass = 'status-bar-info';
            
            statusBar.className = `status-bar ${typeClass}`;
            statusBar.style.display = 'block';

            if (controls) {
                const controlsEl = document.createElement('div');
                controlsEl.className = 'status-bar-controls';
                controls.forEach(control => {
                    const btn = document.createElement('button');
                    btn.textContent = control.text;
                    btn.className = control.className;
                    btn.onclick = control.onClick;
                    controlsEl.appendChild(btn);
                    lucide.createIcons(); // To render icons if any
                });
                statusBar.appendChild(controlsEl);
            } else {
                setTimeout(() => { statusBar.style.display = 'none'; }, 5000);
            }
        }

        function confirmClearCache() {
            confirmAction(
                'Clear Local Cache?',
                'This will delete all your unsaved local changes and reload the latest data from the server. This action cannot be undone.',
                () => {
                    localStorage.removeItem(CACHE_KEY);
                    showStatus('Local cache cleared. Reloading from server...', false, false, true);
                    location.reload();
                }
            );
        }

        function saveToCache() {
            if (!isDataLoaded) return; // Don't save incomplete data
            const cache = {
                spawnData: spawnData,
                undoHistory: undoHistory,
                currentMap: currentMap,
                timestamp: new Date().toISOString()
            };
            localStorage.setItem(CACHE_KEY, JSON.stringify(cache));
        }

        function loadFromCache() {
            try {
                const cache = JSON.parse(localStorage.getItem(CACHE_KEY));
                if (cache && cache.spawnData) {
                    spawnData = cache.spawnData;
                    undoHistory = cache.undoHistory || [];
                    currentMap = cache.currentMap;
                    return true;
                }
            } catch (e) {
                console.error('Failed to parse cache:', e);
                localStorage.removeItem(CACHE_KEY);
            }
            return false;
        }

        // --- Data Loading & Parsing ---
        async function loadData() {
            // 1. Try to load files from server
            let serverData;
            try {
                const response = await fetch(`${SERVER_URL}/api/files`);
                if (!response.ok) throw new Error(`Server responded with status: ${response.status}`);
                serverData = await response.json();
            } catch (error) {
                console.error('Failed to load files from server:', error);
                showStatus(`âœ— Error: Could not load files from the server.`, true);
                const editorContent = document.getElementById('editorContent');
                if (editorContent) {
                    editorContent.innerHTML = `<div class="empty-state"><h3>Connection Failed</h3><p>Could not connect to the server at <strong>${SERVER_URL}</strong>.</p></div>`;
                }
                return;
            }
            
            // 2. We have server data, parse monster list (it's the dependency)
            parseMonsterList(serverData.monsterListXml);

            // 3. Check for local cache
            const hasCache = loadFromCache();
            if (hasCache) {
                showStatus('You have unsaved changes from a previous session.', false, true, false, [
                    { text: 'Load My Changes', className: 'btn btn-warning btn-sm', onClick: () => {
                        finishLoading(true); // true = use cached data
                        showStatus('Loaded changes from local cache.', false, false, true);
                    }},
                    { text: 'Discard (Load from Server)', className: 'btn btn-outline btn-sm', onClick: () => {
                        localStorage.removeItem(CACHE_KEY);
                        parseMonsterSpawn(serverData.monsterSpawnXml);
                        finishLoading(false); // false = use server data
                        showStatus('Discarded local changes. Loaded fresh data from server.', false);
                    }}
                ]);
            } else {
                // No cache, just parse server data and finish
                parseMonsterSpawn(serverData.monsterSpawnXml);
                finishLoading(false);
            }
        }
        
        function finishLoading(usedCache) {
            isDataLoaded = true;
            document.getElementById('mainContent').style.display = 'grid';
            document.getElementById('dataManagementSection').style.display = 'block';
            
            if (Object.keys(spawnData).length > 0) {
                renderMapList();
                if (currentMap && spawnData[currentMap]) {
                    selectMap(currentMap); // Restore last viewed map
                } else {
                    document.getElementById('editorContent').innerHTML = `<div class="empty-state"><h3>Select a Map</h3><p>Choose a map from the list on the left to start editing spawns.</p></div>`;
                }
            } else {
                 document.getElementById('editorContent').innerHTML = `<div class="empty-state"><h3>No Spawn Data Found</h3><p>The MonsterSpawn.xml file might be empty or corrupt.</p></div>`;
            }
            
            if (usedCache) saveToCache(); // Resave to update timestamp
            lucide.createIcons();
        }

        function parseMonsterList(xmlText) {
            const parser = new DOMParser();
            const xmlDoc = parser.parseFromString(xmlText, 'text/xml');
            monsterList = {};
            for (let monster of xmlDoc.getElementsByTagName('Monster')) {
                // Store ID, Type, and NpcFunction (if available in MonsterList.xml)
                monsterList[monster.getAttribute('ID')] = { 
                    name: monster.getAttribute('Name'), 
                    type: monster.getAttribute('Type'),
                    // Default to 'None' if attribute is missing
                    npcFunction: monster.getAttribute('NpcFunction') || 'None' 
                };
            }
        }

        function parseMonsterSpawn(xmlText) {
            const headerMatch = xmlText.match(/^[\s\S]*?(?=<MonsterSpawn>)/i);
            originalXMLHeader = headerMatch ? headerMatch[0] : '<?xml version="1.0" encoding="utf-8"?>\n';
            const parser = new DOMParser();
            const xmlDoc = parser.parseFromString(xmlText, "text/xml");
            spawnData = {};
            const mapNodes = xmlDoc.getElementsByTagName('Map');
            for (const mapNode of mapNodes) {
                const mapNum = mapNode.getAttribute('Number');
                spawnData[mapNum] = { name: mapNode.getAttribute('Name'), spots: [] };
                for (const spotNode of mapNode.getElementsByTagName('Spot')) {
                    const spotData = { type: spotNode.getAttribute('Type'), description: spotNode.getAttribute('Description'), spawns: [] };
                    let lastComment = null;
                    for (const childNode of spotNode.childNodes) {
                        if (childNode.nodeType === 8) {
                            const commentText = childNode.nodeValue.trim();
                            if (commentText.includes("Modified by:")) { lastComment = commentText; }
                        }
                        if (childNode.nodeType === 1 && childNode.nodeName === 'Spawn') {
                            const spawn = {
                                index: childNode.getAttribute('Index'), startX: childNode.getAttribute('StartX'), startY: childNode.getAttribute('StartY'),
                                endX: childNode.getAttribute('EndX'), endY: childNode.getAttribute('EndY'), distance: childNode.getAttribute('Distance'),
                                count: childNode.getAttribute('Count'), dir: childNode.getAttribute('Dir'), npcFunction: childNode.getAttribute('NpcFunction'),
                                element: childNode.getAttribute('Element')
                            };
                            if (lastComment) {
                                const authorMatch = lastComment.match(/Modified by: (.*?) @/);
                                const timestampMatch = lastComment.match(/@ (.*)/);
                                if (authorMatch && timestampMatch) {
                                    spawn.modificationInfo = { author: authorMatch[1], timestamp: timestampMatch[1] };
                                }
                                lastComment = null;
                            }
                            spotData.spawns.push(spawn);
                        }
                    }
                    spawnData[mapNum].spots.push(spotData);
                }
            }
        }

        // --- Undo System ---
        function pushUndo() {
            if (currentMap === null || !spawnData[currentMap]) return;
            if (undoHistory.length >= 50) undoHistory.shift();
            undoHistory.push({ mapNum: currentMap, data: JSON.parse(JSON.stringify(spawnData[currentMap])) });
            updateUndoButton();
            saveToCache(); // Save state on undo
        }

        function executeUndo() {
            if (undoHistory.length === 0) return;
            const lastState = undoHistory.pop();
            if (lastState) {
                spawnData[lastState.mapNum] = lastState.data;
                if (currentMap === lastState.mapNum) {
                    renderMapEditor(currentMap);
                } else {
                    selectMap(lastState.mapNum); // This will call renderMapEditor
                }
            }
            updateUndoButton();
            saveToCache(); // Save state after undo
        }

        function updateUndoButton() {
            const btn = document.getElementById('undoBtn');
            if (btn) {
                btn.disabled = undoHistory.length === 0;
                btn.innerHTML = `<i data-lucide="undo-2"></i> ${undoHistory.length > 0 ? `Undo (${undoHistory.length})` : 'Undo'}`;
                lucide.createIcons();
            }
        }

        function setModificationInfo(spawn) {
            spawn.modificationInfo = { author: getAuthorName(), timestamp: new Date().toLocaleString() };
        }

        document.addEventListener('keydown', (e) => { if (e.ctrlKey && e.key === 'z') { e.preventDefault(); executeUndo(); } });
        
        // --- Map & Spawn Rendering ---
        function renderMapList() {
            const mapListEl = document.getElementById('mapList');
            mapListEl.innerHTML = '';
            const sortedMaps = Object.keys(spawnData).sort((a, b) => parseInt(a) - parseInt(b));
            sortedMaps.forEach(mapNum => {
                const mapItem = document.createElement('div');
                mapItem.className = 'map-item';
                mapItem.id = `map-item-${mapNum}`;
                mapItem.innerHTML = `<span class="map-item-number">${mapNum}</span> ${spawnData[mapNum].name}`;
                mapItem.onclick = () => selectMap(mapNum);
                mapListEl.appendChild(mapItem);
            });
        }

        function selectMap(mapNum) {
            if (activeInlineEditor) cancelActiveInlineEdit();
            currentMap = mapNum;
            saveToCache(); // Save new map selection
            
            document.querySelectorAll('.map-item').forEach(item => item.classList.remove('active'));
            const activeItem = document.getElementById(`map-item-${mapNum}`);
            if (activeItem) {
                activeItem.classList.add('active');
                activeItem.scrollIntoView({ behavior: 'smooth', block: 'nearest' });
            }
            selectedSpawns = [];
            renderMapEditor(mapNum);
        }

        function getSpotDescription(type) {
            const desc = { '0': 'NPC/Traps', '1': 'Multi-Spawn', '2': 'Single-Spawn', '3': 'Multi-Elemental', '4': 'Single-Elemental' };
            return desc[type] || 'Unknown';
        }

        function renderMapEditor(mapNum) {
            cancelActiveInlineEdit();
            const map = spawnData[mapNum];
            const existingTypes = map.spots.map(s => parseInt(s.type));
            const missingTypes = [0, 1, 2, 3, 4].filter(t => !existingTypes.includes(t));
            const spotTypeNames = ['NPC/Traps', 'Multi-Spawn', 'Single-Spawn', 'Multi-Elemental', 'Single-Elemental'];

            // Main header and controls
            let html = `<div><div style="display: flex; justify-content: space-between; align-items: center; margin-bottom: 20px;"><div><h2 style="color: var(--text-bright); margin-bottom: 5px;">${map.name}</h2><p style="color: var(--text-secondary);">Map Number: <span style="font-family: var(--font-data);">${mapNum}</span></p></div><div class="controls" style="display: flex; gap: 10px;">
                <button id="undoBtn" class="btn btn-undo" onclick="executeUndo()" disabled><i data-lucide="undo-2"></i> Undo</button>
                
                <div class="dropdown">
                    <button class="btn btn-primary"><i data-lucide="plus-circle"></i> New Spawn <i data-lucide="chevron-down" style="width: 16px; margin-left: 0;"></i></button>
                    <div class="dropdown-content">
                        ${[0, 1, 2, 3, 4].map(type => `<button onclick="openAddModal(${type})"><i data-lucide="plus"></i> Type ${type} (${spotTypeNames[type]})</button>`).join('')}
                    </div>
                </div>
                
                <button class="btn btn-success" onclick="saveChangesToServer()"><i data-lucide="save"></i> Save Changes</button>
            </div></div>`;

            // Missing categories block (if any exist on map already)
            if (missingTypes.length > 0 && map.spots.length > 0) {
                html += `<div class="glass-effect" style="padding: 15px; margin-bottom: 20px;"><h4 style="margin-bottom: 10px; color: var(--text-secondary);">Add Missing Categories:</h4><div style="display:flex; gap:10px; flex-wrap:wrap;">`;
                missingTypes.forEach(type => {
                    html += `<button class="btn btn-outline" onclick="addMissingCategory(${type})"><i data-lucide="plus"></i> Type ${type} (${spotTypeNames[type]})</button>`;
                });
                html += `</div></div>`;
            }

            // Search bar
            html += `<div class="search-bar" style="margin-bottom: 20px;"><input type="text" id="spawnSearch" placeholder="Search spawns by monster name or ID..." oninput="filterSpawns()"></div>`;

            // Sort spots by type
            map.spots.sort((a, b) => parseInt(a.type) - parseInt(b.type));

            // Empty state
            if (map.spots.length === 0) {
                html += `<div class="empty-state"><h3>No spawns on this map</h3><p>Use the "New Spawn" button above to add categories and spawns.</p></div>`;
            } else {
                // Render each spot type table
                map.spots.forEach((spot, spotIndex) => {
                    const isSingleSpawnType = spot.type === '2' || spot.type === '4';
                    
                    // Table header
                    html += `<div class="spawn-table ${collapsedStates[`${mapNum}-${spot.type}`] ? 'collapsed' : ''}" data-spot-index="${spotIndex}"><h3 onclick="toggleSpot(this.parentElement, ${mapNum}, '${spot.type}')"><div style="display: flex; align-items: center; gap: 8px; flex-wrap: wrap;"><span style="color: var(--text-bright); font-size: 1.1em;">${getSpotDescription(spot.type)}</span><button class="btn btn-primary btn-sm" style="padding: 4px 8px;" onclick="event.stopPropagation(); addNewSpawnRow(${spotIndex})"><i data-lucide="plus"></i></button><button id="copyBtn-${spotIndex}" class="btn btn-primary btn-sm" style="padding: 4px 8px;" onclick="event.stopPropagation(); copySelectedSpawnsFromGroup(${spotIndex})"><i data-lucide="clipboard-copy"></i></button><button id="pasteBtn-${spotIndex}" class="btn btn-success btn-sm" style="padding: 4px 8px;" onclick="event.stopPropagation(); pasteSpawns(${spotIndex})"><i data-lucide="clipboard-paste"></i></button><button id="deleteBtn-${spotIndex}" class="btn btn-danger btn-sm" style="padding: 4px 8px;" onclick="event.stopPropagation(); deleteSelectedSpawns(${spotIndex})"><i data-lucide="trash-2"></i></button></div><span style="display: flex; align-items: center; gap: 10px;"><span style="font-size: 14px; color: var(--text-secondary);">${spot.spawns.length} spawns</span><span class="toggle-icon"><i data-lucide="chevron-down"></i></span></span></h3><table><thead><tr><th><input type="checkbox" title="Select All" onclick="toggleSelectAll(${spotIndex}, this)"></th><th style="cursor: pointer;" onclick="sortTable(${spotIndex}, 'index')">Monster <i data-lucide="arrow-up-down" style="width:12px"></i></th><th style="cursor: pointer;" onclick="sortTable(${spotIndex}, 'startX')">Start (X,Y) <i data-lucide="arrow-up-down" style="width:12px"></i></th>
        <th><div>End (X,Y)</div>
            <div class="th-controls">
                <div class="th-input-group">
                    <button class="th-input-btn" onclick="event.stopPropagation(); changeThInputValue('th-input-endxy-${spotIndex}', -1)">-</button>
                    <input type="number" class="th-input" value="3" id="th-input-endxy-${spotIndex}" onclick="event.stopPropagation();">
                    <button class="th-input-btn" onclick="event.stopPropagation(); changeThInputValue('th-input-endxy-${spotIndex}', 1)">+</button>
                </div>
                <button class="btn-th-apply" onclick="event.stopPropagation(); confirmBulkAction(${spotIndex}, 'applyCoordOffset', 'th-input-endxy-${spotIndex}')">Apply</button>
            </div>
        </th>
        ${!isSingleSpawnType ? `<th style="cursor: pointer;" onclick="sortTable(${spotIndex}, 'count')"><div>Count <i data-lucide="arrow-up-down" style="width:12px"></i></div>
            <div class="th-controls">
                <div class="th-input-group">
                    <button class="th-input-btn" onclick="event.stopPropagation(); changeThInputValue('th-input-count-${spotIndex}', -1)">-</button>
                    <input type="number" class="th-input" value="1" id="th-input-count-${spotIndex}" onclick="event.stopPropagation();">
                    <button class="th-input-btn" onclick="event.stopPropagation(); changeThInputValue('th-input-count-${spotIndex}', 1)">+</button>
                </div>
                <button class="btn-th-apply" onclick="event.stopPropagation(); confirmBulkAction(${spotIndex}, 'applyValue', 'count', 'th-input-count-${spotIndex}')">Apply</button>
            </div>
        </th>` : ''}
        <th style="cursor: pointer;" onclick="sortTable(${spotIndex}, 'distance')">
        <div>Dist <i data-lucide="arrow-up-down" style="width:12px"></i></div>
        <div class="th-controls">
            <div class="th-input-group">
                <button class="th-input-btn" onclick="event.stopPropagation(); changeThInputValue('th-input-dist-${spotIndex}', -1)">-</button>
                <input type="number" class="th-input" value="3" id="th-input-dist-${spotIndex}" onclick="event.stopPropagation();">
                <button class="th-input-btn" onclick="event.stopPropagation(); changeThInputValue('th-input-dist-${spotIndex}', 1)">+</button>
            </div>
            <button class="btn-th-apply" onclick="event.stopPropagation(); confirmBulkAction(${spotIndex}, 'applyValue', 'distance', 'th-input-dist-${spotIndex}')">Apply</button>
        </div></th>
        <th style="cursor: pointer;" onclick="sortTable(${spotIndex}, 'dir')">Dir <i data-lucide="arrow-up-down" style="width:12px"></i></th>
        <th style="cursor: pointer;" onclick="sortTable(${spotIndex}, 'element')">Elem <i data-lucide="arrow-up-down" style="width:12px"></i></th>
        <th>Actions</th></tr></thead><tbody>`;
        // Removed <th>NpcFunc</th>

                    // Render each spawn row
                    spot.spawns.forEach((spawn, spawnIndex) => {
                        html += getSpawnRowHtml(spotIndex, spawnIndex, spot.type);
                    });

                    html += `</tbody></table></div>`;
                });
            }

            html += `</div>`;

            // Render to DOM
            document.getElementById('editorContent').innerHTML = html;
            
            // Post-render updates
            updateUndoButton();
            
            // Re-apply selection visuals
            selectedSpawns.forEach(sel => {
                const row = document.querySelector(`tr[data-spot-index="${sel.spotIndex}"][data-spawn-index="${sel.spawnIndex}"]`);
                if (row) {
                    row.classList.add('spawn-row-selected');
                    const checkbox = row.querySelector('input[type="checkbox"]');
                    if (checkbox) checkbox.checked = true;
                }
            });
            
            updateControls();
            lucide.createIcons();
        }

        // Helper to check if a monster is an NPC/Trap
        function isNpc(monsterIndex) {
            const details = monsterList[monsterIndex];
            if (!details) return false;
            // Type 4 is NPC, Type 8 is Trap/Teleport/similar object
            return details.type === '4' || details.type === '8';
        }
        
        function getSpawnRowHtml(spotIndex, spawnIndex, spotType) {
            const spawn = spawnData[currentMap].spots[spotIndex].spawns[spawnIndex];
            const monsterDetails = monsterList[spawn.index];
            const monsterName = monsterDetails ? monsterDetails.name : `Unknown (${spawn.index})`;
            const isSingleSpawnType = spotType === '2' || spotType === '4';
            
            // The NpcFunction field is no longer displayed here.
            
            const isInvalid = !spawn.index || !spawn.startX || !spawn.startY || (!isSingleSpawnType && !spawn.count);
            let rowClass = spawn.isNew ? 'spawn-row-new' : (spawn.isModified ? 'spawn-row-modified' : '');
            if (isInvalid) rowClass += ' spawn-row-empty';
            
            let modInfoHtml = '';
            if (spawn.modificationInfo) {
                modInfoHtml = `<div class="mod-info"><i data-lucide="info" style="width:12px; color: var(--accent-blue);"></i><span class="mod-info-text">Modified by: ${spawn.modificationInfo.author}<br>On: ${spawn.modificationInfo.timestamp}</span></div>`;
            }
            
            const monsterNameHtml = `<div title="${monsterName}" class="monster-name" style="display:flex; align-items:center; gap: 5px;"><span style="color: ${!spawn.index ? 'var(--accent-pink)' : 'inherit'};">[<span style="font-family: var(--font-data);">${spawn.index || "???"}</span>] ${!spawn.index ? 'Click to Select...' : (monsterName.length > 20 ? monsterName.substring(0, 18) + '...' : monsterName)}</span>${modInfoHtml}</div>`;
            
            // Add invalid classes for inline inputs
            const invalidIndex = !spawn.index ? 'inline-input-invalid' : '';
            const invalidStartX = !spawn.startX ? 'inline-input-invalid' : '';
            const invalidStartY = !spawn.startY ? 'inline-input-invalid' : '';
            const invalidCount = !isSingleSpawnType && !spawn.count ? 'inline-input-invalid' : '';

            return `<tr data-spot-index="${spotIndex}" data-spawn-index="${spawnIndex}" class="${rowClass}">
                <td><input type="checkbox" onclick="toggleSelection(${spotIndex}, ${spawnIndex})"></td>
                <td class="monster-name-cell ${invalidIndex}" onclick="editMonsterInline(this, ${spotIndex}, ${spawnIndex})">${monsterNameHtml}</td>
                <td><div class="coord-group">
                    <input type="number" class="inline-input coord ${invalidStartX}" value="${spawn.startX}" onchange="updateSpawnValue(this, ${spotIndex}, ${spawnIndex}, 'startX', this.value, true)">, 
                    <input type="number" class="inline-input coord ${invalidStartY}" value="${spawn.startY}" onchange="updateSpawnValue(this, ${spotIndex}, ${spawnIndex}, 'startY', this.value, true)">
                </div></td>
                <td><div class="coord-group">
                    <input type="number" class="inline-input coord" value="${spawn.endX}" onchange="updateSpawnValue(this, ${spotIndex}, ${spawnIndex}, 'endX', this.value)">, 
                    <input type="number" class="inline-input coord" value="${spawn.endY}" onchange="updateSpawnValue(this, ${spotIndex}, ${spawnIndex}, 'endY', this.value)">
                    <button class="inline-coord-btn" onclick="setInlineEndCoords(${spotIndex}, ${spawnIndex}, 3)">+3</button>
                    <button class="inline-coord-btn" onclick="setInlineEndCoords(${spotIndex}, ${spawnIndex}, 4)">+4</button>
                    <button class="inline-coord-btn" onclick="setInlineEndCoords(${spotIndex}, ${spawnIndex}, 5)">+5</button>
                </div></td>
                ${!isSingleSpawnType ? `<td><input type="number" class="inline-input ${invalidCount}" value="${spawn.count}" onchange="updateSpawnValue(this, ${spotIndex}, ${spawnIndex}, 'count', this.value, true)"></td>` : ''}
                <td><input type="number" class="inline-input" value="${spawn.distance}" onchange="updateSpawnValue(this, ${spotIndex}, ${spawnIndex}, 'distance', this.value)"></td>
                <td><input type="number" class="inline-input" value="${spawn.dir}" onchange="updateSpawnValue(this, ${spotIndex}, ${spawnIndex}, 'dir', this.value)"></td>
                <td><input type="number" class="inline-input" value="${spawn.element}" onchange="updateSpawnValue(this, ${spotIndex}, ${spawnIndex}, 'element', this.value)"></td>
                <td style="white-space: nowrap;">
                    <button class="action-btn btn-duplicate" title="Duplicate" onclick="duplicateSpawn(${spotIndex}, ${spawnIndex})"><i data-lucide="copy"></i></button>
                    <button class="action-btn btn-edit" title="Edit" onclick="editSpawn(${spotIndex}, ${spawnIndex})"><i data-lucide="edit"></i></button>
                    <button class="action-btn btn-delete" title="Delete" onclick="deleteSpawn(${spotIndex}, ${spawnIndex})"><i data-lucide="trash-2"></i></button>
                </td>
            </tr>`;
            // Removed input for NpcFunction here
        }
        
        function filterMaps() {
            const searchTerm = document.getElementById('mapSearch').value.toLowerCase();
            document.querySelectorAll('.map-item').forEach(item => {
                item.style.display = item.textContent.toLowerCase().includes(searchTerm) ? '' : 'none';
            });
        }
        
        function filterSpawns() {
            const searchTerm = document.getElementById('spawnSearch').value.toLowerCase();
            document.querySelectorAll('.spawn-table').forEach(table => {
                let tableHasVisibleRow = false;
                table.querySelectorAll('tbody tr').forEach(row => {
                    const monsterNameCell = row.querySelector('.monster-name');
                    if (monsterNameCell && monsterNameCell.textContent.toLowerCase().includes(searchTerm)) {
                        row.style.display = '';
                        tableHasVisibleRow = true;
                    } else {
                        row.style.display = 'none';
                    }
                });
                table.style.display = tableHasVisibleRow ? '' : 'none';
                if (searchTerm.length > 0 && tableHasVisibleRow) {
                    table.classList.remove('collapsed');
                }
            });
        }
        
        function toggleSpot(tableElement, mapNum, spotType) { 
            tableElement.classList.toggle('collapsed'); 
            collapsedStates[`${mapNum}-${spotType}`] = tableElement.classList.contains('collapsed'); 
        }
        
        // --- Refactored Spawn Value Update (No Full Re-render) ---
        function updateSpawnValue(inputElement, spotIndex, spawnIndex, field, value, isRequired = false) { 
            const spawn = spawnData[currentMap].spots[spotIndex].spawns[spawnIndex]; 
            
            // NpcFunction check is no longer needed here as the input is removed from the table.
            // If the user somehow manages to edit it (e.g., via the modal, which is hidden),
            // the logic in spawnForm submit and selectMonsterInline will ensure consistency.

            if (spawn[field] !== value) { 
                if (!spawn.isNew) pushUndo(); // Push undo *before* changing
                
                spawn[field] = value; 
                
                if (!spawn.isNew) { 
                    spawn.isModified = true; 
                    setModificationInfo(spawn); 
                    
                    // Update modification info bubble if it exists
                    const row = document.querySelector(`tr[data-spot-index="${spotIndex}"][data-spawn-index="${spawnIndex}"]`);
                    if (row) {
                        row.classList.add('spawn-row-modified');
                        const modInfo = row.querySelector('.mod-info');
                        if (modInfo) {
                            modInfo.querySelector('.mod-info-text').innerHTML = `Modified by: ${spawn.modificationInfo.author}<br>On: ${spawn.modificationInfo.timestamp}`;
                        } else {
                            // If it was a new spawn, it's now modified, and needs the info bubble added
                            // This is complex to do without re-render, but for now, just adding the class is fine
                            // A full re-render on *first* edit of a new spawn might be acceptable
                        }
                    }
                }
                
                // Re-validate and update row/input class
                validateSpawnRow(spotIndex, spawnIndex, inputElement);
                
                saveToCache();
            }
        }
        
        function validateSpawnRow(spotIndex, spawnIndex, changedInputElement = null) {
            const row = document.querySelector(`tr[data-spot-index="${spotIndex}"][data-spawn-index="${spawnIndex}"]`);
            if (!row) return;

            const spot = spawnData[currentMap].spots[spotIndex];
            const spawn = spot.spawns[spawnIndex];
            const isSingleSpawnType = spot.type === '2' || spot.type === '4';

            let isInvalid = false;
            
            // Validate Index
            const nameCell = row.querySelector('.monster-name-cell');
            if (!spawn.index) {
                isInvalid = true;
                if (nameCell) nameCell.classList.add('inline-input-invalid');
            } else {
                if (nameCell) nameCell.classList.remove('inline-input-invalid');
            }
            
            // Validate StartX
            const startXInput = row.querySelector(`input[onchange*="startX"]`);
            if (!spawn.startX) {
                isInvalid = true;
                if (startXInput) startXInput.classList.add('inline-input-invalid');
            } else {
                if (startXInput) startXInput.classList.remove('inline-input-invalid');
            }
            
            // Validate StartY
            const startYInput = row.querySelector(`input[onchange*="startY"]`);
            if (!spawn.startY) {
                isInvalid = true;
                if (startYInput) startYInput.classList.add('inline-input-invalid');
            } else {
                if (startYInput) startYInput.classList.remove('inline-input-invalid');
            }

            // Validate Count
            if (!isSingleSpawnType) {
                const countInput = row.querySelector(`input[onchange*="count"]`);
                if (!spawn.count) {
                    isInvalid = true;
                    if (countInput) countInput.classList.add('inline-input-invalid');
                } else {
                    if (countInput) countInput.classList.remove('inline-input-invalid');
                }
            }
            
            row.classList.toggle('spawn-row-empty', isInvalid);
        }

        function addMissingCategory(type) { 
            pushUndo(); 
            const typeStr = type.toString(); 
            const newSpot = { type: typeStr, description: getSpotDescription(typeStr), spawns: [] }; 
            spawnData[currentMap].spots.push(newSpot); 
            spawnData[currentMap].spots.sort((a, b) => parseInt(a.type) - parseInt(b.type)); 
            renderMapEditor(currentMap); // Full re-render needed
            saveToCache();
        }
        
        function addNewSpawnRow(spotIndex) { 
            pushUndo(); 
            // Default NpcFunction to 'None' or the inherent value if the monster is later selected.
            const newSpawn = { index: '', startX: '', startY: '', endX: '0', endY: '0', distance: '0', count: '1', dir: '-1', npcFunction: 'None', element: '0', isNew: true }; 
            setModificationInfo(newSpawn); 
            spawnData[currentMap].spots[spotIndex].spawns.unshift(newSpawn); 
            renderMapEditor(currentMap); // Full re-render needed
            saveToCache();
        }
        
        function cancelActiveInlineEdit() {
            if (!activeInlineEditor) return;
            document.removeEventListener('click', handleGlobalClickForInlineEdit);
            document.querySelectorAll('.editing-child-visible').forEach(el => el.classList.remove('editing-child-visible'));
            const { td, spotIndex, spawnIndex } = activeInlineEditor;
            
            // Get fresh HTML for just this row
            const spotType = spawnData[currentMap].spots[spotIndex].type;
            const rowHtml = getSpawnRowHtml(spotIndex, spawnIndex, spotType);
            
            // Create a temporary row to parse
            const tempTable = document.createElement('table');
            tempTable.innerHTML = rowHtml;
            const newRow = tempTable.rows[0];
            
            // Find the cell we need
            const newTd = newRow.querySelector('.monster-name-cell');
            
            // Replace the old cell's content
            if (newTd) {
                td.innerHTML = newTd.innerHTML;
                td.className = newTd.className; // Sync classes (like invalid status)
                td.setAttribute('onclick', `editMonsterInline(this, ${spotIndex}, ${spawnIndex})`);
            }
            
            activeInlineEditor = null;
            lucide.createIcons();
        }

        function editMonsterInline(td, spotIndex, spawnIndex) {
            cancelActiveInlineEdit();
            activeInlineEditor = { td, spotIndex, spawnIndex };
            td.removeAttribute('onclick');
            const tableContainer = td.closest('.spawn-table');
            if (tableContainer) tableContainer.classList.add('editing-child-visible');
            const spawn = spawnData[currentMap].spots[spotIndex].spawns[spawnIndex];
            const currentMonsterName = monsterList[spawn.index] ? monsterList[spawn.index].name : '';
            td.innerHTML = `<div class="monster-search"><input type="text" class="inline-input" style="width:100%;" value="${currentMonsterName}" oninput="showInlineSuggestions(this, ${spotIndex}, ${spawnIndex})" onkeydown="if(event.key === 'Escape') cancelActiveInlineEdit();" autocomplete="off"><div class="monster-suggestions"></div></div>`;
            const input = td.querySelector('input');
            input.focus();
            input.select();
            showInlineSuggestions(input, spotIndex, spawnIndex);
            setTimeout(() => document.addEventListener('click', handleGlobalClickForInlineEdit), 0);
        }
        
        function handleGlobalClickForInlineEdit(event) { if (activeInlineEditor && !activeInlineEditor.td.contains(event.target)) cancelActiveInlineEdit(); }
        
        function showInlineSuggestions(input, spotIndex, spawnIndex) {
            const searchTerm = input.value.toLowerCase();
            const suggestionsDiv = input.nextElementSibling;
            const spotType = spawnData[currentMap].spots[spotIndex].type;
            const isNpcTrapSpot = spotType === '0';
            let html = '';
            let count = 0;
            for (const [id, details] of Object.entries(monsterList)) {
                if (count >= 15) break;
                const monsterType = details.type;
                if ((isNpcTrapSpot && (monsterType !== '4' && monsterType !== '8')) || (!isNpcTrapSpot && (monsterType === '4' || monsterType === '8'))) continue; 
                if (id.includes(searchTerm) || details.name.toLowerCase().includes(searchTerm)) {
                    html += `<div class="suggestion-item" onmousedown="event.preventDefault(); selectMonsterInline(${spotIndex}, ${spawnIndex}, '${id}')"><span class="suggestion-item-id">${id}</span> ${details.name.replace(/'/g, "\\'")}</div>`;
                    count++;
                }
            }
            suggestionsDiv.innerHTML = html;
            suggestionsDiv.classList.toggle('show', !!html);
        }

        function selectMonsterInline(spotIndex, spawnIndex, newIndex) {
            const spawn = spawnData[currentMap].spots[spotIndex].spawns[spawnIndex];
            
            if (spawn.index !== newIndex) {
                if (!spawn.isNew) pushUndo();
                spawn.index = newIndex;
                if (!spawn.isNew) {
                    spawn.isModified = true;
                    setModificationInfo(spawn);
                }
                
                // --- NEW LOGIC: Automatically set NpcFunction if the new index is an NPC ---
                const details = monsterList[newIndex];
                if (isNpc(newIndex) && details && details.npcFunction) {
                    spawn.npcFunction = details.npcFunction;
                } else {
                     // If switching to a non-NPC, set to 'None'
                     spawn.npcFunction = 'None';
                }
                // --- END NEW LOGIC ---
            }
            
            cancelActiveInlineEdit(); // This will re-render the row with the correct data
            validateSpawnRow(spotIndex, spawnIndex); // Re-validate
            saveToCache();
        }
        
        // --- Modal & Editing Logic ---
        function openAddModal(preselectedType) { 
            editingSpawnIndex = null; 
            addingToSpotIndex = null; 
            document.getElementById('modalTitle').textContent = 'Add New Spawn'; 
            document.getElementById('spawnForm').reset(); 
            document.getElementById('monsterIndex').value = ''; 
            
            const spawnTypeSelect = document.getElementById('spawnType');
            spawnTypeSelect.value = preselectedType;
            spawnTypeSelect.disabled = false; // Always allow change, just pre-select
            
            // Hide NpcFunction in modal for simplicity, as it's auto-populated on monster selection
            document.getElementById('npcFunctionGroup').style.display = 'none';
            document.getElementById('npcFunction').value = 'None';
            
            updateSpawnTypeRestrictions(); 
            document.getElementById('spawnModal').classList.add('show'); 
            lucide.createIcons(); 
        }
        
        function duplicateSpawn(spotIndex, spawnIndex) { 
            pushUndo(); 
            const originalSpawn = spawnData[currentMap].spots[spotIndex].spawns[spawnIndex]; 
            const newSpawn = JSON.parse(JSON.stringify(originalSpawn)); 
            newSpawn.isNew = true; 
            delete newSpawn.isModified; 
            setModificationInfo(newSpawn); 
            // NpcFunction is automatically copied in JSON.stringify/parse and stays correct
            spawnData[currentMap].spots[spotIndex].spawns.splice(spawnIndex + 1, 0, newSpawn); 
            renderMapEditor(currentMap); // Full re-render needed
            saveToCache();
        }
        
        function editSpawn(spotIndex, spawnIndex) { 
            const spawn = spawnData[currentMap].spots[spotIndex].spawns[spawnIndex]; 
            editingSpawnIndex = { spot: spotIndex, spawn: spawnIndex }; 
            
            const isNpcSpawn = isNpc(spawn.index);

            document.getElementById('modalTitle').textContent = 'Edit Spawn Details'; 
            document.getElementById('monsterSearch').value = `[${spawn.index}] ${monsterList[spawn.index] ? monsterList[spawn.index].name : 'Unknown'}`; 
            document.getElementById('monsterIndex').value = spawn.index; 
            document.getElementById('spawnType').value = spawnData[currentMap].spots[spotIndex].type; 
            document.getElementById('spawnType').disabled = true; 
            document.getElementById('startX').value = spawn.startX; 
            document.getElementById('startY').value = spawn.startY; 
            document.getElementById('endX').value = spawn.endX; 
            document.getElementById('endY').value = spawn.endY; 
            document.getElementById('distance').value = spawn.distance; 
            document.getElementById('spawnCount').value = spawn.count; 
            document.getElementById('dir').value = spawn.dir; 
            document.getElementById('element').value = spawn.element; 
            
            // NpcFunction input is now hidden/disabled in the modal since it's determined by Monster ID
            document.getElementById('npcFunctionGroup').style.display = 'none';
            document.getElementById('npcFunction').value = spawn.npcFunction;
            document.getElementById('npcFunction').disabled = true;
            
            updateSpawnTypeRestrictions(); 
            document.getElementById('spawnModal').classList.add('show'); 
            lucide.createIcons(); 
        }
        
        function deleteSpawn(spotIndex, spawnIndex) { 
            confirmAction(
                'Delete Spawn?',
                'Are you sure you want to delete this spawn?',
                () => {
                    pushUndo(); 
                    spawnData[currentMap].spots[spotIndex].spawns.splice(spawnIndex, 1); 
                    if (spawnData[currentMap].spots[spotIndex].spawns.length === 0) {
                        spawnData[currentMap].spots.splice(spotIndex, 1);
                    }
                    renderMapEditor(currentMap); // Full re-render needed
                    saveToCache();
                }
            );
        }
        
        function closeModal() { document.getElementById('spawnModal').classList.remove('show'); }
        
        document.getElementById('monsterSearch').addEventListener('input', function (e) { 
            let html = ''; 
            let count = 0; 
            const searchTerm = e.target.value.toLowerCase(); 
            const suggestions = document.getElementById('monsterSuggestions'); 
            const isNpc = document.getElementById('spawnType').value === '0'; 
            for (const [id, details] of Object.entries(monsterList)) { 
                if (count >= 10) break; 
                const monsterType = details.type;
                if ((isNpc && (monsterType !== '4' && monsterType !== '8')) || (!isNpc && (monsterType === '4' || monsterType === '8'))) continue; 
                if (id.includes(searchTerm) || details.name.toLowerCase().includes(searchTerm)) { 
                    html += `<div class="suggestion-item" onclick="selectMonster('${id}', '${details.name.replace(/'/g, "\\'")}')"><span class="suggestion-item-id">${id}</span> ${details.name}</div>`; 
                    count++; 
                } 
            } 
            suggestions.innerHTML = html; 
            suggestions.classList.toggle('show', !!html); 
        });
        
        function selectMonster(id, name) { 
            document.getElementById('monsterSearch').value = `[${id}] ${name}`; 
            document.getElementById('monsterIndex').value = id; 
            document.getElementById('monsterSuggestions').classList.remove('show'); 
            
            // When selecting a monster in the modal, set the NpcFunction based on monsterList data
            const npcFunctionInput = document.getElementById('npcFunction');
            const details = monsterList[id];

            if (isNpc(id) && details && details.npcFunction) {
                npcFunctionInput.value = details.npcFunction;
            } else {
                npcFunctionInput.value = 'None';
            }
            // The input remains hidden/disabled, but its value is correctly set.
        }
        
        function updateSpawnTypeRestrictions() { 
            const spawnType = document.getElementById('spawnType').value; 
            document.getElementById('npcWarning').style.display = spawnType === '0' ? 'inline' : 'none'; 
            
            const isSingle = spawnType === '2' || spawnType === '4';
            document.getElementById('spawnCount').disabled = isSingle;
            if (isSingle) document.getElementById('spawnCount').value = '1';
        }
        
        function setEndCoords(addValue, mode) { 
            if (mode === 'modal') { 
                const startX = parseInt(document.getElementById('startX').value) || 0; 
                const startY = parseInt(document.getElementById('startY').value) || 0; 
                document.getElementById('endX').value = startX + addValue; 
                document.getElementById('endY').value = startY + addValue; 
            } 
        }
        
        function setInlineEndCoords(spotIndex, spawnIndex, addValue) { 
            pushUndo(); 
            const spawn = spawnData[currentMap].spots[spotIndex].spawns[spawnIndex]; 
            spawn.endX = (parseInt(spawn.startX) + addValue).toString(); 
            spawn.endY = (parseInt(spawn.startY) + addValue).toString(); 
            if (!spawn.isNew) { 
                spawn.isModified = true; 
                setModificationInfo(spawn); 
            } 
            renderMapEditor(currentMap); // Re-render to show new values
            saveToCache();
        }
        
        function sortTable(spotIndex, columnKey) { 
            const sortKey = `${currentMap}-${spotIndex}-${columnKey}`; 
            sortDirections[sortKey] = sortDirections[sortKey] === 'asc' ? 'desc' : 'asc'; 
            const direction = sortDirections[sortKey]; 
            spawnData[currentMap].spots[spotIndex].spawns.sort((a, b) => { 
                let valA = parseInt(a[columnKey]) || 0; 
                let valB = parseInt(b[columnKey]) || 0; 
                return direction === 'asc' ? valA - valB : valB - a[columnKey]; // Use direct attribute for non-numeric keys if needed, but here all are strings of numbers
            }); 
            renderMapEditor(currentMap); // Full re-render needed
        }
        
        document.getElementById('spawnForm').addEventListener('submit', function (e) { 
            e.preventDefault(); 
            const monsterIndex = document.getElementById('monsterIndex').value;
            if (!monsterIndex) { 
                showStatus('Please select a valid monster', true); 
                return; 
            } 

            pushUndo(); 
            const spawnType = document.getElementById('spawnType').value; 
            
            // Determine NpcFunction based on selected Monster Index, overriding the modal input (which is hidden/disabled)
            const details = monsterList[monsterIndex];
            const autoNpcFunction = (isNpc(monsterIndex) && details && details.npcFunction) ? details.npcFunction : 'None';
            
            const newSpawnData = { 
                index: monsterIndex, 
                startX: document.getElementById('startX').value, 
                startY: document.getElementById('startY').value, 
                endX: document.getElementById('endX').value, 
                endY: document.getElementById('endY').value, 
                distance: document.getElementById('distance').value, 
                count: document.getElementById('spawnCount').value, 
                dir: document.getElementById('dir').value, 
                element: document.getElementById('element').value, 
                // Use the auto-determined NpcFunction
                npcFunction: autoNpcFunction
            }; 
            
            if (editingSpawnIndex) { 
                const spawnToUpdate = spawnData[currentMap].spots[editingSpawnIndex.spot].spawns[editingSpawnIndex.spawn]; 
                
                // No need for final check on modification, as the value is automatically derived from the monster index
                Object.assign(spawnToUpdate, newSpawnData); 
                if (!spawnToUpdate.isNew) spawnToUpdate.isModified = true; 
                setModificationInfo(spawnToUpdate); 
            } else { 
                newSpawnData.isNew = true; 
                setModificationInfo(newSpawnData); 
                let spotIndex = spawnData[currentMap].spots.findIndex(s => s.type === spawnType); 
                if (spotIndex === -1) { 
                    spawnData[currentMap].spots.push({ type: spawnType, description: getSpotDescription(spawnType), spawns: [newSpawnData] }); 
                    spawnData[currentMap].spots.sort((a, b) => parseInt(a.type) - parseInt(b.type)); 
                } else { 
                    spawnData[currentMap].spots[spotIndex].spawns.unshift(newSpawnData); 
                } 
            } 
            closeModal(); 
            renderMapEditor(currentMap); // Full re-render needed
            saveToCache();
        });
        
        // --- Selection & Clipboard Logic ---
        function updateControls() { 
            if (!spawnData[currentMap]) return; 
            spawnData[currentMap].spots.forEach((spot, spotIndex) => { 
                const selectedCount = selectedSpawns.filter(s => s.spotIndex === spotIndex).length; 
                const copyBtn = document.getElementById(`copyBtn-${spotIndex}`); 
                if (copyBtn) { 
                    copyBtn.disabled = selectedCount === 0; 
                    copyBtn.innerHTML = selectedCount > 0 ? `<i data-lucide="clipboard-copy"></i> (${selectedCount})` : `<i data-lucide="clipboard-copy"></i>`; 
                } 
                const pasteBtn = document.getElementById(`pasteBtn-${spotIndex}`); 
                if (pasteBtn) { 
                    pasteBtn.disabled = spawnClipboard.length === 0 || (clipboardSourceType === '0') !== (spot.type === '0'); 
                } 
                const deleteBtn = document.getElementById(`deleteBtn-${spotIndex}`); 
                if (deleteBtn) { 
                    deleteBtn.disabled = selectedCount === 0; 
                    deleteBtn.innerHTML = selectedCount > 0 ? `<i data-lucide="trash-2"></i> (${selectedCount})` : `<i data-lucide="trash-2"></i>`; 
                } 
            }); 
            lucide.createIcons(); 
        }
        
        function findSelectionIndex(spotIndex, spawnIndex) { return selectedSpawns.findIndex(s => s.spotIndex === spotIndex && s.spawnIndex === spawnIndex); }
        
        function toggleSelection(spotIndex, spawnIndex) { 
            const selectionIndex = findSelectionIndex(spotIndex, spawnIndex); 
            const row = document.querySelector(`tr[data-spot-index="${spotIndex}"][data-spawn-index="${spawnIndex}"]`); 
            if (selectionIndex > -1) { 
                selectedSpawns.splice(selectionIndex, 1); 
                if (row) row.classList.remove('spawn-row-selected'); 
            } else { 
                selectedSpawns.push({ spotIndex, spawnIndex }); 
                if (row) row.classList.add('spawn-row-selected'); 
            } 
            const checkbox = row.querySelector('input[type="checkbox"]'); 
            if (checkbox) checkbox.checked = selectionIndex === -1; 
            updateControls(); 
        }
        
        function toggleSelectAll(spotIndex, masterCheckbox) { 
            const shouldSelect = masterCheckbox.checked; 
            
            // Get all visible rows (spawns) in this spot group
            const spotSpawns = spawnData[currentMap].spots[spotIndex].spawns;

            spotSpawns.forEach((spawn, spawnIndex) => { 
                const selectionIndex = findSelectionIndex(spotIndex, spawnIndex); 
                const row = document.querySelector(`tr[data-spot-index="${spotIndex}"][data-spawn-index="${spawnIndex}"]`);
                
                if (shouldSelect) { 
                    if (selectionIndex === -1) {
                         selectedSpawns.push({ spotIndex, spawnIndex }); 
                         if (row) row.classList.add('spawn-row-selected');
                    }
                } else { 
                    if (selectionIndex > -1) {
                        selectedSpawns.splice(selectionIndex, 1);
                        if (row) row.classList.remove('spawn-row-selected');
                    }
                } 
                // Ensure the individual checkbox matches the master checkbox state
                const checkbox = row ? row.querySelector('input[type="checkbox"]') : null;
                if (checkbox) checkbox.checked = shouldSelect;
            }); 

            updateControls(); 
            // We don't need a full renderMapEditor call here, as we update the visuals directly in the loop.
        }
        
        function copySelectedSpawnsFromGroup(spotIndexToCopy) { 
            const spawnsToCopy = selectedSpawns.filter(sel => sel.spotIndex === spotIndexToCopy); 
            if (spawnsToCopy.length === 0) return; 
            spawnClipboard = []; 
            clipboardSourceType = spawnData[currentMap].spots[spotIndexToCopy].type; 
            spawnsToCopy.forEach(sel => { 
                spawnClipboard.push(JSON.parse(JSON.stringify(spawnData[currentMap].spots[sel.spotIndex].spawns[sel.spawnIndex]))); 
            }); 
            selectedSpawns = []; 
            renderMapEditor(currentMap); // Full re-render needed
        }
        
        function pasteSpawns(destinationSpotIndex) { 
            if (spawnClipboard.length === 0) return; 
            if ((clipboardSourceType === '0') !== (spawnData[currentMap].spots[destinationSpotIndex].type === '0')) { 
                showStatus("Paste Error: Cannot mix NPC/Trap and monster spawns.", true); 
                return; 
            } 
            pushUndo(); 
            const spawnsToPaste = spawnClipboard.map(spawn => { 
                const newSpawn = JSON.parse(JSON.stringify(spawn)); 
                newSpawn.isNew = true; 
                delete newSpawn.isModified; 
                setModificationInfo(newSpawn); 
                return newSpawn; 
            }); 
            spawnData[currentMap].spots[destinationSpotIndex].spawns.unshift(...spawnsToPaste); 
            renderMapEditor(currentMap); // Full re-render needed
            saveToCache();
        }
        
        function deleteSelectedSpawns(spotIndex) { 
            const spawnsToDelete = selectedSpawns.filter(sel => sel.spotIndex === spotIndex);
            if (spawnsToDelete.length === 0) return; 

            confirmAction(
                `Delete ${spawnsToDelete.length} Spawns?`,
                'Are you sure you want to delete all selected spawns in this group?',
                () => {
                    const spawnIndicesToDelete = spawnsToDelete.map(sel => sel.spawnIndex).sort((a, b) => b - a);
                    pushUndo(); 
                    spawnIndicesToDelete.forEach(spawnIndex => spawnData[currentMap].spots[spotIndex].spawns.splice(spawnIndex, 1)); 
                    selectedSpawns = selectedSpawns.filter(sel => sel.spotIndex !== spotIndex); 
                    if (spawnData[currentMap].spots[spotIndex].spawns.length === 0) {
                        spawnData[currentMap].spots.splice(spotIndex, 1);
                    }
                    renderMapEditor(currentMap); // Full re-render needed
                    saveToCache();
                }
            );
        }

        // --- Bulk Actions ---
        function changeThInputValue(inputId, delta) {
            const input = document.getElementById(inputId);
            if (input) {
                let currentValue = parseInt(input.value, 10);
                if (isNaN(currentValue)) currentValue = 0;
                input.value = currentValue + delta;
            }
        }

        function confirmBulkAction(spotIndex, action, ...args) {
            let title = 'Apply Bulk Action?';
            let message = 'Are you sure you want to apply this change to ALL spawns in this group?';
            let value;
            let inputId;

            if (action === 'applyCoordOffset') {
                inputId = args[0];
                value = document.getElementById(inputId)?.value;
                if (value === undefined || value === '') {
                    showStatus('Cannot apply empty value.', true);
                    return;
                }
                title = `Apply +${value} Offset?`;
                message = `This will set End X/Y to Start X/Y + ${value} for ALL spawns in this group.`;
            } else if (action === 'applyValue') {
                const fieldName = args[0].charAt(0).toUpperCase() + args[0].slice(1);
                inputId = args[1];
                value = document.getElementById(inputId)?.value;
                if (value === undefined || value === '') {
                    showStatus('Cannot apply empty value.', true);
                    return;
                }
                title = `Set ${fieldName} to ${value}?`;
                message = `This will set '${fieldName}' to '${value}' for ALL spawns in this group.`;
            }

            confirmAction(title, message, () => {
                if (action === 'applyCoordOffset') applyCoordOffsetToGroup(spotIndex, parseInt(value, 10));
                if (action === 'applyValue') applyValueToGroup(spotIndex, args[0], value);
            }, 'btn-warning');
        }

        function applyCoordOffsetToGroup(spotIndex, offset) { 
            pushUndo(); 
            spawnData[currentMap].spots[spotIndex].spawns.forEach(spawn => { 
                if (spawn.startX && spawn.startY) { 
                    spawn.endX = (parseInt(spawn.startX, 10) + offset).toString(); 
                    spawn.endY = (parseInt(spawn.startY, 10) + offset).toString(); 
                    if (!spawn.isNew) { 
                        spawn.isModified = true; 
                        setModificationInfo(spawn); 
                    } 
                } 
            }); 
            renderMapEditor(currentMap); // Full re-render needed
            saveToCache();
        }
        
        function applyValueToGroup(spotIndex, field, value) { 
            pushUndo(); 
            spawnData[currentMap].spots[spotIndex].spawns.forEach(spawn => { 
                spawn[field] = value.toString(); 
                if (!spawn.isNew) { 
                    spawn.isModified = true; 
                    setModificationInfo(spawn); 
                } 
            }); 
            renderMapEditor(currentMap); // Full re-render needed
            saveToCache();
        }
        
        // --- Modal & Guide Logic ---
        function openGuideModal() { document.getElementById('guideModal').classList.add('show'); lucide.createIcons(); }
        function closeGuideModal() { document.getElementById('guideModal').classList.remove('show'); }
        
        // Close modals on outside click
        document.getElementById('spawnModal').addEventListener('click', function (e) { if (e.target === this) closeModal(); }); 
        document.getElementById('guideModal').addEventListener('click', function (e) { if (e.target === this) closeGuideModal(); }); 
        document.getElementById('confirmModal').addEventListener('click', function (e) { if (e.target === this) closeConfirmModal(); }); 
        
        // Global click listener for suggestions
        document.addEventListener('click', function (e) { if (!e.target.closest('.monster-search')) document.getElementById('monsterSuggestions').classList.remove('show'); });
        
        // --- Save to Server ---
        async function saveChangesToServer() { 
            const saveButton = document.querySelector('.btn-success'); 
            saveButton.disabled = true; 
            saveButton.innerHTML = `<i data-lucide="loader-2" class="spin"></i> Saving...`; 
            lucide.createIcons(); 
            document.querySelectorAll('.spin').forEach(el => el.animate([{ transform: 'rotate(0deg)' }, { transform: 'rotate(360deg)' }], { duration: 1000, iterations: Infinity }));
            
            let xml = originalXMLHeader + '<MonsterSpawn>\n'; 
            let invalidSpawnsSkipped = 0;
            
            Object.keys(spawnData).sort((a, b) => parseInt(a) - parseInt(b)).forEach(mapNum => { 
                const mapData = spawnData[mapNum]; 
                if (mapData.spots.length === 0) return; 
                xml += `  <Map Number="${mapNum}" Name="${mapData.name}">\n`; 
                mapData.spots.sort((a, b) => parseInt(a.type) - parseInt(b.type)); 
                mapData.spots.forEach(spot => { 
                    xml += `    <Spot Type="${spot.type}" Description="${spot.description}">\n`; 
                    spot.spawns.forEach(spawn => { 
                        const isSingle = spot.type === '2' || spot.type === '4'; 
                        
                        // VALIDATION: Skip invalid spawns
                        const isInvalid = !spawn.index || !spawn.startX || !spawn.startY || (!isSingle && !spawn.count);
                        if (isInvalid) {
                            invalidSpawnsSkipped++;
                            return; // Skip this spawn
                        }
                        
                        // Add modification comment
                        if (spawn.modificationInfo) xml += `      \n`; 
                        
                        const count = isSingle ? "1" : spawn.count; 
                        
                        // Ensure NpcFunction is included, even if not visible in the editor
                        const npcFunctionAttr = spawn.npcFunction && spawn.npcFunction !== 'None' ? ` NpcFunction="${spawn.npcFunction}"` : '';

                        xml += `      <Spawn Index="${spawn.index}" StartX="${spawn.startX}" StartY="${spawn.startY}" EndX="${spawn.endX}" EndY="${spawn.endY}" Distance="${spawn.distance}" Count="${count}" Dir="${spawn.dir}"${npcFunctionAttr} Element="${spawn.element}" />\n`; 
                    }); 
                    xml += `    </Spot>\n`; 
                }); 
                xml += `  </Map>\n`; 
            }); 
            xml += '</MonsterSpawn>'; 
            
            try { 
                const response = await fetch(`${SERVER_URL}/api/save`, { method: 'POST', headers: { 'Content-Type': 'application/json' }, body: JSON.stringify({ newXmlContent: xml }), }); 
                if (!response.ok) throw new Error(`Server responded with status: ${response.status}`); 
                
                let successMessage = 'âœ“ Changes saved successfully to the server!';
                if (invalidSpawnsSkipped > 0) {
                    successMessage += ` (${invalidSpawnsSkipped} invalid spawns were skipped.)`;
                    showStatus(successMessage, false, true); // Show as warning
                } else {
                    showStatus(successMessage, false);
                }
                
                // Clear cache on successful save
                localStorage.removeItem(CACHE_KEY);
                // Reload data to clear 'new'/'modified' status
                loadData();
                
            } catch (error) { 
                console.error('Failed to save changes:', error); 
                showStatus(`âœ— Error: Could not save changes. Your work is still cached locally.`, true); 
            } finally { 
                saveButton.disabled = false; 
                saveButton.innerHTML = `<i data-lucide="save"></i> Save Changes`; 
                lucide.createIcons(); 
            } 
        }
    </script>
</body>
</html>