<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Monster Drop Manager (Each Monster in Each Map)</title>

    <link rel="preconnect" href="https://fonts.googleapis.com">
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
    <link href="https://fonts.googleapis.com/css2?family=Fira+Code:wght@500&family=Inter:wght@400;600;700&display=swap" rel="stylesheet">

    <script src="https://unpkg.com/lucide@latest"></script>

    <style>
        :root {
            --bg-dark: #0a0f1e;
            --bg-glass: rgba(26, 34, 63, 0.6);
            --text-primary: #e0e0e0;
            --text-secondary: #a0a0c0;
            --text-bright: #ffffff;
            --font-ui: 'Inter', sans-serif;
            --font-data: 'Fira Code', monospace;
            
            --accent-blue: #00aaff;
            --accent-green: #00ff9b;
            --accent-amber: #ffc107;
            --accent-pink: #ff0055;
            --accent-purple: #6f42c1;
        }
        
        * { margin: 0; padding: 0; box-sizing: border-box; }
        
        body {
            font-family: var(--font-ui);
            background: linear-gradient(135deg, #1a223f 0%, var(--bg-dark) 100%);
            color: var(--text-primary);
            min-height: 100vh;
            padding: 20px;
        }
        
        .container {
            max-width: 95%; 
            margin: 0 auto;
            background: transparent;
            border-radius: 12px;
            padding: 30px;
            display: flex;
            flex-direction: column;
            gap: 20px;
        }

        .glass-effect {
            background: var(--bg-glass);
            backdrop-filter: blur(10px);
            -webkit-backdrop-filter: blur(10px);
            border: 1px solid rgba(0, 170, 255, 0.2);
            border-radius: 12px;
            box-shadow: 0 8px 32px 0 rgba(0, 0, 0, 0.37);
        }
        
        .header { position: relative; padding: 30px; text-align: center; }
        .header .header-controls { position: absolute; top: 25px; left: 30px; display: flex; align-items: center; gap: 10px; background: rgba(0, 170, 255, 0.1); padding: 8px 12px; border-radius: 6px; }
        .header .header-controls label { font-weight: 600; font-size: 14px; }
        .header h1 { font-size: 28px; margin-bottom: 10px; color: var(--text-bright); display: flex; align-items: center; justify-content: center; gap: 15px; }
        .header p { color: var(--text-secondary); }
        
        .status-bar { display: none; padding: 15px; border-radius: 8px; font-weight: 600; margin-bottom: 20px; }
        .status-bar-success { background: rgba(0, 255, 155, 0.2); color: var(--accent-green); border: 1px solid var(--accent-green); }
        .status-bar-error { background: rgba(255, 0, 85, 0.2); color: var(--accent-pink); border: 1px solid var(--accent-pink); }
        .status-bar-warning { background: rgba(255, 193, 7, 0.2); color: var(--accent-amber); border: 1px solid var(--accent-amber); }
        .status-bar-info { background: rgba(0, 170, 255, 0.2); color: var(--accent-blue); border: 1px solid var(--accent-blue); }
        
        .main-content { display: grid; grid-template-columns: 300px 1fr; gap: 20px; }
        .sidebar h3 { display: flex; align-items: center; gap: 10px; margin-bottom: 15px; color: var(--text-bright); }
        .map-list { max-height: 70vh; overflow-y: auto; }
        .map-item { padding: 10px; margin-bottom: 5px; background: transparent; color: var(--text-secondary); border-radius: 6px; cursor: pointer; transition: all 0.2s; border-left: 3px solid transparent; font-size: 14px; }
        .map-item:hover { background: rgba(0, 170, 255, 0.1); color: var(--text-primary); border-left-color: var(--accent-blue); }
        .map-item.active { background: var(--accent-blue); color: var(--bg-dark); font-weight: 600; border-left-color: var(--accent-amber); }
        .map-item-number { font-weight: bold; margin-right: 8px; font-family: var(--font-data); }
        .search-bar input { width: 100%; padding: 12px; border: 1px solid rgba(0, 170, 255, 0.2); border-radius: 6px; font-size: 14px; background-color: rgba(0,0,0,0.3); color: var(--text-primary); }
        .search-bar input:focus { outline: none; border-color: var(--accent-blue); }

        .btn { padding: 10px 18px; border: none; border-radius: 6px; font-size: 14px; font-weight: 600; cursor: pointer; transition: all 0.3s; display: inline-flex; align-items: center; gap: 8px; }
        .btn:disabled { opacity: 0.4; cursor: not-allowed; }
        .btn-primary { background: var(--accent-blue); color: var(--bg-dark); }
        .btn-primary:hover:not(:disabled) { background: #fff; }
        .btn-success { background: var(--accent-green); color: var(--bg-dark); }
        .btn-success:hover:not(:disabled) { background: #fff; }
        .btn-danger { background: var(--accent-pink); color: #fff; }
        .btn-danger:hover:not(:disabled) { background: #fff; color: var(--accent-pink); }
        .btn-outline { background: transparent; border: 1px solid rgba(0, 170, 255, 0.5); color: var(--accent-blue); }
        .btn-outline:hover { background: rgba(0, 170, 255, 0.1); }
        
        .editor-panel-header { display: flex; justify-content: space-between; align-items: center; margin-bottom: 20px; flex-wrap: wrap; gap: 15px; }
        .editor-panel-header .search-bar { flex-grow: 1; min-width: 250px; }
        
        .table-wrapper { overflow-x: auto; max-height: 70vh; background: rgba(0,0,0,0.2); border-radius: 8px; }
        table { width: 100%; border-collapse: collapse; min-width: 2000px; }
        th { background: rgba(0, 170, 255, 0.1); color: var(--text-bright); padding: 10px 12px; text-align: left; font-weight: 600; font-size: 12px; vertical-align: top; position: sticky; top: 0; z-index: 10; }
        td { padding: 8px 12px; border-bottom: 1px solid rgba(0, 170, 255, 0.1); vertical-align: middle; font-size: 13px; background: var(--bg-glass); }
        tr:hover td { background: rgba(0, 170, 255, 0.05); }

        .spawn-row-new td { background-color: rgba(0, 255, 155, 0.1) !important; }
        .spawn-row-modified td { background-color: rgba(255, 193, 7, 0.1) !important; }

        tr.selected td {
            background: rgba(255, 0, 85, 0.2) !important;
            outline: 1px solid var(--accent-pink);
        }
        th.checkbox-col, td.checkbox-col {
            width: 40px;
            min-width: 40px;
            padding-left: 15px;
            padding-right: 5px;
            text-align: center;
            position: sticky;
            left: 0;
            z-index: 1;
        }
        
        th.checkbox-col {
            z-index: 11;
            background: rgba(0, 170, 255, 0.1);
        }

        th:nth-child(2), td:nth-child(2) {
            position: sticky;
            left: 40px; 
            z-index: 1;
        }
        
        th:nth-child(2) {
             background: rgba(0, 170, 255, 0.1);
             z-index: 11;
        }

        tr:hover td:nth-child(1), tr:hover td:nth-child(2) {
            background: rgba(0, 170, 255, 0.05);
        }
        tr.selected td:nth-child(1), tr.selected td:nth-child(2) {
            background: rgba(255, 0, 85, 0.2) !important;
        }


        input[type="checkbox"] {
            width: 16px;
            height: 16px;
            accent-color: var(--accent-pink);
            cursor: pointer;
            vertical-align: middle;
        }

        .inline-input { width: 100%; min-width: 50px; padding: 4px 6px; border: 1px solid transparent; background: rgba(0,0,0,0.3); border-radius: 4px; font-family: var(--font-data); font-size: 13px; transition: all 0.2s; color: var(--text-primary); }
        .inline-input:hover, .inline-input:focus { border-color: var(--accent-blue); background: var(--bg-dark); }
        .inline-input.wide { min-width: 120px; }
        
        input[type=number]::-webkit-inner-spin-button, input[type=number]::-webkit-outer-spin-button { -webkit-appearance: none; margin: 0; }
        input[type=number] { -moz-appearance: textfield; appearance: textfield; }
        
        .monster-name, .item-name { font-weight: 600; color: var(--text-primary); font-size: 13px; cursor: help; white-space: nowrap; }
        .item-name-col { min-width: 180px; }
        .monster-name-col { min-width: 160px; }
        
        .modal { display: none; position: fixed; top: 0; left: 0; width: 100%; height: 100%; background: rgba(0, 0, 0, 0.7); z-index: 1000; align-items: center; justify-content: center; }
        .modal.show { display: flex; }
        
        .modal-content { box-shadow: 0 8px 32px 0 rgba(0,0,0,0.5); color: var(--text-primary); max-width: 1000px; width: 90%; max-height: 90vh; overflow-y: auto; }
        .modal-header { display: flex; justify-content: space-between; align-items: center; padding: 20px 25px; border-bottom: 1px solid rgba(0, 170, 255, 0.2); }
        .modal-header h2 { color: var(--text-bright); }
        .modal-body { padding: 25px; }
        .modal-footer { display: flex; gap: 10px; justify-content: flex-end; padding: 20px 25px; border-top: 1px solid rgba(0, 170, 255, 0.2); }
        .close-btn { color: var(--text-secondary); transition: all 0.2s; background: none; border: none; cursor: pointer;}
        .close-btn:hover { color: var(--text-bright); transform: rotate(90deg); }
        
        .form-grid { display: grid; grid-template-columns: repeat(auto-fit, minmax(150px, 1fr)); gap: 15px; }
        .form-group.full-width { grid-column: 1 / -1; }
        .form-grid label { display: block; margin-bottom: 5px; font-weight: 600; color: var(--text-secondary); font-size: 12px; }
        .form-group input, .form-group select { width: 100%; padding: 8px 10px; border: 1px solid rgba(0, 170, 255, 0.2); border-radius: 6px; font-size: 14px; background-color: rgba(0,0,0,0.3); color: var(--text-primary); font-family: var(--font-data); }
        .form-group input:focus, .form-group select:focus { outline: none; border-color: var(--accent-blue); }
        
        .monster-search, .item-search { position: relative; }
        .suggestions { background: var(--bg-dark); border: 1px solid var(--accent-blue); position: absolute; top: 100%; left: 0; right: 0; max-height: 200px; overflow-y: auto; z-index: 100; display: none; }
        .suggestions.show { display: block; }
        .suggestion-item { padding: 10px; cursor: pointer; border-bottom: 1px solid rgba(0, 170, 255, 0.1); }
        .suggestion-item:hover { background: rgba(0, 170, 255, 0.1); }
        .suggestion-item-id { color: var(--accent-blue); font-family: var(--font-data); margin-right: 8px; }
        .suggestion-item-cat { color: var(--accent-amber); font-family: var(--font-data); margin-right: 8px; }

        
        .form-divider {
            grid-column: 1 / -1;
            display: flex;
            align-items: center;
            gap: 10px;
            margin: 10px 0;
            color: var(--accent-blue);
        }
        .form-divider hr {
            flex-grow: 1;
            border: none;
            border-top: 1px solid rgba(0, 170, 255, 0.2);
        }
        .form-divider h4 {
            font-weight: 600;
        }

        .action-btn { padding: 5px; border-radius: 4px; cursor: pointer; background: transparent; border: none; color: var(--text-secondary); }
        .action-btn:hover { color: var(--text-bright); }
        .btn-delete:hover { color: var(--accent-pink); }
        .btn-duplicate:hover { color: var(--accent-blue); }
        .btn-view:hover { color: var(--accent-amber); }
        .empty-state { text-align: center; padding: 60px 20px; color: var(--text-secondary); }
        
        .load-more-container {
            text-align: center;
            padding: 20px 0;
        }

        #undoRedoControls button {
            background: rgba(0, 170, 255, 0.1);
            color: var(--accent-blue);
        }
        #undoRedoControls button:disabled {
            opacity: 0.2;
            cursor: not-allowed;
            color: var(--text-secondary);
        }


        ::-webkit-scrollbar { width: 8px; height: 8px; }
        ::-webkit-scrollbar-track { background: transparent; }
        ::-webkit-scrollbar-thumb { background: var(--accent-blue); border-radius: 4px; }
        ::-webkit-scrollbar-thumb:hover { background: #fff; }

        .btn i, .action-btn i, h1 i, h3 i { width: 16px; height: 16px; stroke-width: 2.5; }
        .action-btn i { width: 18px; height: 18px; }
        .header h1 i { width: 32px; height: 32px; color: var(--accent-blue); }
    
        /* --- New Tooltip CSS --- */
        .rpg-tooltip {
            display: none;
            position: absolute;
            z-index: 2000;
            background: rgba(10, 15, 30, 0.95);
            border: 1px solid var(--accent-blue);
            border-radius: 8px;
            padding: 12px;
            width: 300px;
            font-family: var(--font-ui);
            font-size: 13px;
            box-shadow: 0 4px 20px rgba(0, 0, 0, 0.5);
            backdrop-filter: blur(5px);
            -webkit-backdrop-filter: blur(5px);
            pointer-events: none; /* So it doesn't block mouseout events */
            transition: opacity 0.1s;
        }
        .rpg-tooltip h3 {
            color: var(--accent-amber);
            font-size: 16px;
            margin-bottom: 8px;
            padding-bottom: 8px;
            border-bottom: 1px solid rgba(0, 170, 255, 0.2);
            font-weight: 600;
        }
        .rpg-tooltip .stats-grid {
            display: grid;
            grid-template-columns: 1fr 1fr;
            gap: 4px 10px;
        }
        .rpg-tooltip .stat {
            display: flex;
            justify-content: space-between;
        }
        .rpg-tooltip .stat strong {
            color: var(--text-secondary);
        }
        .rpg-tooltip .stat span {
            color: var(--text-primary);
            font-weight: 600;
            font-family: var(--font-data);
        }
        .rpg-tooltip .stat-divider {
            border: none;
            border-top: 1px dashed rgba(0, 170, 255, 0.2);
            margin: 8px 0;
        }
        .rpg-tooltip .reqs .stat strong {
             color: var(--accent-pink);
        }
        .rpg-tooltip .class-list {
            margin-top: 8px;
            font-size: 12px;
        }
        .rpg-tooltip .class-list strong {
            color: var(--text-secondary);
        }
        .rpg-tooltip .class-list span {
            color: var(--accent-green);
        }
    </style>
</head>
<body>
    
    <!-- --- New Tooltip HTML Element --- -->
    <div id="itemTooltip" class="rpg-tooltip"></div>

    <div class="modal" id="confirmModal">
        <div class="modal-content glass-effect" style="max-width: 500px;">
            <div class="modal-header">
                <h2 id="confirmTitle">Are you sure?</h2>
                <button class="close-btn" onclick="closeConfirmModal()"><i data-lucide="x"></i></button>
            </div>
            <div class="modal-body">
                <p id="confirmMessage" style="color: var(--text-secondary); line-height: 1.6;">This action cannot be undone.</p>
            </div>
            <div class="modal-footer">
                <button class="btn btn-outline" onclick="closeConfirmModal()">Cancel</button>
                <button id="confirmButton" class="btn btn-danger">Confirm</button>
            </div>
        </div>
    </div>
    
    <div class="container glass-effect">
        <div class="header">
            <h1><i data-lucide="droplets"></i>Monster Drop Editor<i data-lucide="package"></i></h1>
            <p>Manage item drops for each map bag file (<code>EachMonsterMapDrop</code>)</p>
            
            <div class="header-right-controls" style="position: absolute; top: 25px; right: 30px; display: flex; gap: 10px;">
                <a href="dashboard.html" class="btn btn-outline" title="Back to Dashboard">
                    <i data-lucide="layout-dashboard"></i>Dashboard
                </a>
                <button class="btn btn-outline" onclick="openGuideModal()"><i data-lucide="help-circle"></i>Guide</button>
            </div>
            
            <div class="header-controls" id="undoRedoControls">
                <button class="btn btn-outline" id="undoBtn" disabled title="Undo (Ctrl+Z)" onclick="undoChange()">
                    <i data-lucide="undo-2"></i> Undo
                </button>
                <button class="btn btn-outline" id="redoBtn" disabled title="Redo (Ctrl+Y / Cmd+Shift+Z)" onclick="redoChange()">
                    <i data-lucide="redo-2"></i> Redo
                </button>
            </div>
        </div>
        
        <div id="statusBar" class="status-bar"></div>
        
        <div class="main-content" id="mainContent">
            <div class="sidebar glass-effect" style="padding: 20px;">
                <h3><i data-lucide="map"></i>Map Bag Files</h3>
                <div class="search-bar" style="margin-bottom: 15px;"><input type="text" id="mapSearch" oninput="filterMapFiles()" placeholder="Search map files..."></div>
                <div class="map-list" id="mapFileList"></div>
            </div>
            <div class="editor-panel glass-effect" style="padding: 25px;">
                <div id="editorContent">
                    <div class="empty-state">
                        <h3>Loading data...</h3>
                        <p>Fetching map drop files, item lists, and monster lists from the server.</p>
                    </div>
                </div>
            </div>
        </div>
    </div>
    
    <div class="modal" id="dropModal">
        <div class="modal-content glass-effect">
            <div class="modal-header">
                <h2 id="modalTitle">Add New Drop Item</h2>
                <button class="close-btn" onclick="closeModal()"><i data-lucide="x"></i></button>
            </div>
            <form id="dropForm">
                <div class="modal-body">
                    <div class="form-grid">
                        <div class="form-group full-width monster-search">
                            <label>Monster *</label>
                            <input type="text" id="monsterSearch" autocomplete="off" required>
                            <input type="hidden" id="monsterID">
                            <div class="suggestions" id="monsterSuggestions"></div>
                        </div>
                        
                        <div class="form-group full-width item-search">
                            <label>Item *</label>
                            <input type="text" id="itemSearch" autocomplete="off" required>
                            <input type="hidden" id="itemCat">
                            <input type="hidden" id="itemIndex">
                            <div class="suggestions" id="itemSuggestions"></div>
                        </div>
                        
                        <div class="form-group"><label>Monster Element</label><input type="number" id="monsterElement" value="-1"></div>
                        <div class="form-group"><label>Player Min Reset</label><input type="number" id="playerMinReset" value="-1"></div>
                        <div class="form-group"><label>Player Max Reset</label><input type="number" id="playerMaxReset" value="-1"></div>
                        <div class="form-group"><label>Player Min Level</label><input type="number" id="playerMinLevel" value="-1"></div>
                        <div class="form-group"><label>Player Max Level</label><input type="number" id="playerMaxLevel" value="-1"></div>
                        
                        <div class="form-group"><label>Min Level</label><input type="number" id="minLevel" value="0" min="0" max="15"></div>
                        <div class="form-group"><label>Max Level</label><input type="number" id="maxLevel" value="0" min="0" max="15"></div>
                        <div class="form-group"><label>Durability</label><input type="number" id="durability" value="0"></div>
                        <div class="form-group"><label>Skill</label><input type="number" id="skill" value="-1"></div>
                        <div class="form-group"><label>Luck</label><input type="number" id="luck" value="-1"></div>
                        <div class="form-group"><label>Option</label><input type="number" id="option" value="0"></div>
                        
                        <div class="form-group"><label>Exc</label><input type="text" id="exc" value="-1"></div>
                        <div class="form-group"><label>Element</label><input type="number" id="element" value="0"></div>
                        <div class="form-group"><label>SocketCount</label><input type="text" id="socketCount" value="0;0"></div>
                        <div class="form-group"><label>Duration</label><input type="number" id="duration" value="0"></div>

                        <div class="form-group"><label>Rate *</label><input type="number" id="rate" value="1000" required></div>
                    </div>
                </div>
                <div class="modal-footer">
                    <button type="button" class="btn btn-outline" onclick="closeModal()">Cancel</button>
                    <button type="submit" class="btn btn-success">Save</button>
                </div>
            </form>
        </div>
    </div>

    <div class="modal" id="bulkEditModal">
        <div class="modal-content glass-effect">
            <div class="modal-header">
                <h2 id="bulkModalTitle">Bulk Edit Drops</h2>
                <button class="close-btn" onclick="closeBulkModal()"><i data-lucide="x"></i></button>
            </div>
            <form id="bulkEditForm">
                <div class="modal-body">
                    
                    <div id="bulkFindSection">
                        <div class="form-divider">
                            <i data-lucide="search"></i>
                            <h4>FIND (WHEN NO ROWS ARE SELECTED)</h4>
                            <hr>
                        </div>
                        
                        <div class="form-grid">
                            <div class="form-group full-width monster-search">
                                <label>Find Monster *</label>
                                <input type="text" id="bulkFindMonsterSearch" autocomplete="off">
                                <input type="hidden" id="bulkFindMonsterID">
                                <div class="suggestions" id="bulkFindMonsterSuggestions"></div>
                            </div>
                            
                            <div class="form-group full-width item-search">
                                <label>Find Item (Optional)</label>
                                <input type="text" id="bulkFindItemSearch" autocomplete="off" placeholder="Leave blank to target all items from this monster">
                                <input type="hidden" id="bulkFindItemCat">
                                <input type="hidden" id="bulkFindItemIndex">
                                <div class="suggestions" id="bulkFindItemSuggestions"></div>
                            </div>
                        </div>
                    </div>

                    <div class="form-divider">
                        <i data-lucide="refresh-cw"></i>
                        <h4>REPLACE WITH (OPTIONAL)</h4>
                        <hr>
                    </div>

                    <p style="color: var(--accent-amber); font-size: 13px; margin-bottom: 15px; grid-column: 1 / -1;">
                        Leave blank to only modify the item properties below.
                    </p>

                    <div class="form-grid">
                        <div class="form-group full-width item-search">
                            <label>New Item</label>
                            <input type="text" id="bulkReplaceItemSearch" autocomplete="off" placeholder="Leave blank to keep current item">
                            <input type="hidden" id="bulkReplaceItemCat">
                            <input type="hidden" id="bulkReplaceItemIndex">
                            <div class="suggestions" id="bulkReplaceItemSuggestions"></div>
                        </div>
                    </div>

                    <div class="form-divider">
                        <i data-lucide="settings-2"></i>
                        <h4>SET NEW VALUES (OPTIONAL)</h4>
                        <hr>
                    </div>

                    <p style="color: var(--text-secondary); font-size: 13px; margin-bottom: 15px; grid-column: 1 / -1;">
                        Only fill in the fields you want to change. Blank fields will keep their original values.
                    </p>

                    <div class="form-grid">
                        <div class="form-group"><label>Min Level</label><input type="number" id="bulkMinLevel" placeholder="e.g., 0" min="0" max="15"></div>
                        <div class="form-group"><label>Max Level</label><input type="number" id="bulkMaxLevel" placeholder="e.g., 0" min="0" max="15"></div>
                        <div class="form-group"><label>Durability</label><input type="number" id="bulkDurability" placeholder="e.g., 0"></div>
                        <div class="form-group"><label>Skill</label><input type="text" id="bulkSkill" placeholder="e.g., -1"></div>
                        <div class="form-group"><label>Luck</label><input type="text" id="bulkLuck" placeholder="e.g., -1"></div>
                        <div class="form-group"><label>Option</label><input type="text" id="bulkOption" placeholder="e.g., 0"></div>
                        <div class="form-group"><label>Exc</label><input type="text" id="bulkExc" placeholder="e.g., -1"></div>
                        <div class="form-group"><label>SocketCount</label><input type="text" id="bulkSocketCount" placeholder="e.g., 0;0"></div>
                        <div class="form-group"><label>Duration</label><input type="number" id="bulkDuration" placeholder="e.g., 0"></div>
                        <div class="form-group"><label>Rate *</label><input type="number" id="bulkRate" placeholder="e.g., 1000"></div>
                    </div>
                </div>
                <div class="modal-footer">
                    <button type="button" class="btn btn-outline" onclick="closeBulkModal()">Cancel</button>
                    <button type="submit" class="btn btn-success">Apply Bulk Edit</button>
                </div>
            </form>
        </div>
    </div>
    
    <div class="modal" id="rateAdjustModal">
        <div class="modal-content glass-effect" style="max-width: 600px;">
            <div class="modal-header">
                <h2 id="rateAdjustModalTitle">Adjust All Drop Rates</h2>
                <button class="close-btn" onclick="closeRateAdjustModal()"><i data-lucide="x"></i></button>
            </div>
            <form id="rateAdjustForm">
                <div class="modal-body">
                    <p id="rateAdjustInfo" style="color: var(--text-secondary); font-size: 14px; margin-bottom: 20px;">
                        This will multiply all drop rates in the current file (<strong><span id="rateAdjustFileName"></span></strong>) by a percentage.
                    </p>
                    <div class="form-group full-width">
                        <label for="rateAdjustPercent">Enter Percentage</label>
                        <input type="number" id="rateAdjustPercent" placeholder="e.g., '50' for 50%, '150' for 150%" required oninput="calculateRateChange()">
                    </div>
                    
                    <div id="rateAdjustPreview" style="background: rgba(0,0,0,0.2); padding: 15px; border-radius: 6px; margin-top: 20px;">
                        <p style="color: var(--text-secondary);">Enter a percentage to preview changes.</p>
                    </div>
                    
                </div>
                <div class="modal-footer">
                    <button type="button" class="btn btn-outline" onclick="closeRateAdjustModal()">Cancel</button>
                    <button type="submit" class="btn btn-success">Apply Adjustment</button>
                </div>
            </form>
        </div>
    </div>
    
    <div class="modal" id="guideModal">
        <div class="modal-content glass-effect">
            <div class="modal-header">
                <h2><i data-lucide="help-circle"></i> How to Use the Drop Editor</h2>
                <button class="close-btn" onclick="closeGuideModal()"><i data-lucide="x"></i></button>
            </div>
            <div class="modal-body" id="guideContent" style="line-height: 1.7; color: var(--text-secondary);">
                <h3>1. Getting Started</h3>
                <ul>
                    <li>This editor allows you to edit the <strong>Monster Map Drop</strong> files (<code>MonsterMap_..._Bag.xml</code>).</li>
                    <li>Select a map file from the list on the left to load its drop table.</li>
                </ul>

                <h3>2. Editing Drops</h3>
                <ul>
                    <li><strong>Inline Editing:</strong> Click any value in the table to edit it directly. Press <strong>Enter</strong> to save the change to the table.</li>
                    <li><strong>Item/Monster Names:</strong> Hover over the Monster ID or Item (Cat/Index) to see their names.</li>
                    <li><strong>Add New Drop:</strong> Click the "Add New Drop" button. You can search for monsters and items by name or ID in the modal.</li>
                    <li><strong>Delete Drop:</strong> Click the red trash can icon at the end of a row to delete a drop. You will be asked to confirm.</li>
                    <li><strong>Delete Selected:</strong> Click the checkbox on rows to select them, then click the <strong>Delete Selected</strong> button.</li>
                    <li><strong>Duplicate Drop:</strong> Click the blue copy icon to quickly duplicate an existing drop row.</li>
                    <li><strong>Bulk Edit:</strong> Use the "Bulk Edit" button.
                        <ul>
                            <li><strong>If rows are selected:</strong> It will apply changes (New Item / New Values) <strong>only to selected rows</strong>.</li>
                            <li><strong>If no rows are selected:</strong> It will use the "Find" criteria to apply changes to <strong>all matching rows in the file</strong>.</li>
                        </ul>
                    </li>
                    <li><strong>Adjust Rates:</strong> Use the "Adjust Rates" button.
                        <ul>
                            <li><strong>If rows are selected:</strong> It will apply the percentage adjustment <strong>only to selected rows</strong>.</li>
                            <li><strong>If no rows are selected:</strong> It will apply the adjustment to <strong>all rows in the file</strong>.</li>
                        </ul>
                    </li>
                </ul>
                
                <h3>3. Filtering</h3>
                <ul>
                    <li>Use the <strong>Search Map Files</strong> bar to find a specific map file.</li>
                    <li>Once a map is loaded, use the <strong>Search Drops...</strong> bar to filter the table by Monster ID, Monster Name, Item ID (Cat\_Index), or Item Name.</li>
                </ul>

                <h3>4. Field Definitions (from <code>### Each Bag System Description ###.txt</code>)</h3>
                <ul>
                    <li><strong>MonsterID:</strong> The monster that drops the item.</li>
                    <li><strong>MonsterElement:</strong> -1 for any, 0-5 for specific elements.</li>
                    <li><strong>Player Resets/Levels:</strong> -1 for any, or set min/max values.</li>
                    <li><strong>Cat/Index:</strong> The item's category and index.</li>
                    <li><strong>Min/Max Level:</strong> Item level range (0-15).</li>
                    <li><strong>Skill/Luck:</strong> -1 for random, 0 for no, 1 for yes.</li>
                    <li><strong>Option:</strong> -1 for random, 0 for no, or 1-7 for specific option levels.</li>
                    <li><strong>Exc:</strong> -1 for no exc, -2 for random, etc. Refer to the <code>.txt</code> file for advanced options.</li>
                    <li><strong>SocketCount:</strong> "min;max" format (e.g., "1;3"). 0;0 for default.</li>
                    <li><strong>Rate:</strong> The drop chance. The sum of all rates in one file should not exceed 100,000,000.</li>
                </ul>

                <h3>5. Saving Your Work</h3>
                 <ul>
                    <li>Click the <strong><i data-lucide="save" style="width:14px; height: 14px; display: inline-block; vertical-align: middle;"></i> Save Changes</strong> button.</li>
                    <li>This sends your edits for the <strong>currently selected map file</strong> to the server, creates a backup, and saves the new file.</li>
                    <li><strong>You must save changes for each map file individually.</strong></li>
                </ul>
            </div>
            <div class="modal-footer">
                <button class="btn btn-primary" onclick="closeGuideModal()">Got it!</button>
            </div>
        </div>
    </div>

        <script>
        const SERVER_URL = '';
        
        let monsterList = {}; 
        let itemList = {};    
        let itemCategories = {}; 
        let mapDropFiles = []; 
        let fileContentCache = {}; 
        let loadedContextFiles = {}; 
        let currentFile = null;
        let originalXMLHeaders = {}; 
        let currentDropData = []; 
        let editingDropIndex = null; 
        
        const MAX_HISTORY = 20;
        let history = [];
        let historyIndex = -1; 
        
        let currentVisibleRows = 100;
        const ROWS_PER_PAGE = 100;
        
        let selectedRows = new Set();

        const MAP_NAMES = {
            0: "Lorencia",
            1: "Dungeon",
            2: "Devias",
            3: "Noria",
            4: "Losttower",
            5: "Exile",
            6: "Stadium",
            7: "Atlans",
            8: "Tarkan",
            9: "Devil Square", 
            10: "Icarus",
            11: "Blood Castle 1", 
            12: "Blood Castle 2", 
            13: "Blood Castle 3", 
            14: "Blood Castle 4", 
            15: "Blood Castle 5", 
            16: "Blood Castle 6", 
            17: "Blood Castle 7", 
            18: "Chaos Castle 1", 
            19: "Chaos Castle 2", 
            20: "Chaos Castle 3", 
            21: "Chaos Castle 4", 
            22: "Chaos Castle 5", 
            23: "Chaos Castle 6", 
            24: "Kalima 1",
            25: "Kalima 2",
            26: "Kalima 3",
            27: "Kalima 4",
            28: "Kalima 5",
            29: "Kalima 6",
            30: "Valley Of Loren",
            31: "Land Of Trials",
            32: "Devil Square (Event)", 
            33: "Aida",
            34: "Crywolf",
            35: "Illusion Temple", 
            36: "Kalima 7",
            37: "Kanturu",
            38: "Kanturu Core",
            39: "Kanturu Boss",
            40: "Event Zone",
            41: "Barracks",
            42: "Refuge",
            51: "Elbeland",
            52: "Blood Castle 8", 
            53: "Chaos Castle 7", 
            56: "Swamp of Peace",
            57: "Raklion",
            62: "XMas",
            63: "Vulcanus",
            64: "PK Field (Vulcanus)", 
            65: "Doppelganger", 
            64: "Doppelganger", 
            69: "Acheron", 
            79: "Loren Market",
            80: "Kalrutan 1",
            81: "Karutan 2",
            91: "Acheron 1",
            95: "Debenter",
            100: "Uruk Mountain 1",
            110: "Nars",
            112: "Ferea",
            113: "Nixies Lake",
            114: "Quest Zone",
            116: "Deep Dungeon 1",
            117: "Deep Dungeon 2",
            118: "Deep Dungeon 3",
            119: "Deep Dungeon 4",
            120: "Deep Dungeon 5",
            122: "Swamp of Darkness",
            123: "Kubera Mine",
            124: "Kubera Mine",
            125: "Kubera Mine",
            126: "Kubera Mine",
            127: "Kubera Mine",
            128: "Abyss of Atlans 1",
            129: "Abyss of Atlans 2",
            130: "Abyss of Atlans 3",
            131: "Scorched Canyon",
            132: "Red Smoke Icarus",
            133: "Arenil Temple",
            134: "Ashen Aida",
            135: "Old Kethotum",
            136: "Blaze Kethotum",
            137: "Kanturu Undergrounds",
            138: "Ignis Volcano",
            140: "Bloody Tarkan",
            141: "Tormenta Island",
            142: "Twisted Karutan",
            143: "Kardamahal Underground Temple"
        };
        
        document.addEventListener('DOMContentLoaded', () => {
            lucide.createIcons();
            loadData();
        });

        function updateHistory(data) {
            if (historyIndex < history.length - 1) {
                history = history.slice(0, historyIndex + 1);
            }
            
            const newState = JSON.parse(JSON.stringify(data));
            history.push(newState);

            if (history.length > MAX_HISTORY) {
                history.shift(); 
            }
            
            historyIndex = history.length - 1;
            updateUndoRedoButtons();
        }

        function updateUndoRedoButtons() {
            const undoBtn = document.getElementById('undoBtn');
            const redoBtn = document.getElementById('redoBtn');

            if (undoBtn) undoBtn.disabled = historyIndex <= 0;
            if (redoBtn) redoBtn.disabled = historyIndex >= history.length - 1;
        }

        function undoChange() {
            if (historyIndex > 0) {
                historyIndex--;
                currentDropData = JSON.parse(JSON.stringify(history[historyIndex]));
                selectedRows.clear(); 
                renderEditorPanel();
                updateUndoRedoButtons();
                showStatus('Undo successful.', false);
            } else {
                showStatus('Nothing to undo.', true, true);
            }
        }

        function redoChange() {
            if (historyIndex < history.length - 1) {
                historyIndex++;
                currentDropData = JSON.parse(JSON.stringify(history[historyIndex]));
                selectedRows.clear(); 
                renderEditorPanel();
                updateUndoRedoButtons();
                showStatus('Redo successful.', false);
            } else {
                showStatus('Nothing to redo.', true, true);
            }
        }
        
        document.addEventListener('keydown', (e) => {
            if (!currentFile) return; 

            const isInputFocused = document.activeElement.tagName === 'INPUT' || document.activeElement.tagName === 'TEXTAREA';
            if (isInputFocused) return;

            if ((e.ctrlKey || e.metaKey) && e.key === 'z') { 
                e.preventDefault();
                undoChange();
            }
            if (((e.ctrlKey || e.metaKey) && e.key === 'y') || ((e.metaKey && e.shiftKey) && e.key === 'Z')) { 
                e.preventDefault();
                redoChange();
            }
        });


        function confirmAction(title, message, onConfirm, buttonClass = 'btn-danger') {
            document.getElementById('confirmTitle').textContent = title;
            document.getElementById('confirmMessage').textContent = message;
            const confirmButton = document.getElementById('confirmButton');
            confirmButton.className = `btn ${buttonClass}`;
            confirmButton.onclick = () => {
                onConfirm();
                closeConfirmModal();
            };
            document.getElementById('confirmModal').classList.add('show');
            lucide.createIcons();
        }

        function closeConfirmModal() {
            document.getElementById('confirmModal').classList.remove('show');
        }

        function showStatus(message, isError = false, isWarning = false) {
            const statusBar = document.getElementById('statusBar');
            statusBar.textContent = message;
            
            let typeClass = 'status-bar-success';
            if (isError) typeClass = 'status-bar-error';
            else if (isWarning) typeClass = 'status-bar-warning';
            
            statusBar.className = `status-bar ${typeClass}`;
            statusBar.style.display = 'block';

            setTimeout(() => { statusBar.style.display = 'none'; }, 5000);
        }

        async function loadData() {
            try {
                const response = await fetch(`${SERVER_URL}/api/map-drop-data`);
                
                if (!response.ok) {
                    const errorText = await response.text();
                    console.error('Server responded with an error:', errorText);
                    throw new Error(`Server responded with status: ${response.status}. Message: ${errorText.substring(0, 200)}...`);
                }

                const contentType = response.headers.get('content-type');
                if (!contentType || !contentType.includes('application/json')) {
                    const responseText = await response.text();
                    console.error('Expected JSON, but got:', responseText);
                    throw new Error(`Expected JSON response from server, but got ${contentType}. Response: ${responseText.substring(0, 200)}...`);
                }

                const data = await response.json();

                parseMonsterList(data.monsterListXml);
                parseItemList(data.itemListXml);
                mapDropFiles = data.mapDropFiles;
                
                loadedContextFiles.masteryExc = data.masteryExcOptionsXml;
                loadedContextFiles.pentagram = data.pentagramDropRateXml;
                loadedContextFiles.socket = data.socketItemDropRatesXml;
                loadedContextFiles.ini = data.itemDropRateControlIni;
                
                renderMapFileList();
                document.getElementById('editorContent').innerHTML = `<div class="empty-state"><h3>Select a Map Bag File</h3><p>Choose a file from the list on the left to start editing drops.</p></div>`;

            } catch (error) {
                console.error('Failed to load data from server:', error);
                showStatus(`âœ— Error: Could not load files from the server. ${error.message}`, true);
                const editorContent = document.getElementById('editorContent');
                if (editorContent) {
                    editorContent.innerHTML = `<div class="empty-state"><h3>Connection Failed</h3><p>Could not connect to the server at <strong>${SERVER_URL}</strong>.</p><p style="color: var(--accent-pink); font-family: var(--font-data);">${error.message}</p></div>`;
                }
            }
        }

        function parseMonsterList(xmlText) {
            const parser = new DOMParser();
            const xmlDoc = parser.parseFromString(xmlText, 'text/xml');
            monsterList = {};
            for (let monster of xmlDoc.getElementsByTagName('Monster')) {
                monsterList[monster.getAttribute('ID')] = monster.getAttribute('Name');
            }
        }

        function parseItemList(xmlText) {
            const parser = new DOMParser();
            const xmlDoc = parser.parseFromString(xmlText, "text/xml");
            itemList = {};
            itemCategories = {}; 
            for (let category of xmlDoc.getElementsByTagName('Category')) {
                const catIndex = parseInt(category.getAttribute('Index'), 10);
                if (isNaN(catIndex)) continue; 
                
                itemCategories[catIndex] = category.getAttribute('Name');
                itemList[catIndex] = {};
                
                for (let item of category.getElementsByTagName('Item')) {
                    const itemIndex = parseInt(item.getAttribute('Index'), 10);
                    if (isNaN(itemIndex)) continue; 
                    
                    // --- MODIFIED ---
                    // Was: itemList[catIndex][itemIndex] = item.getAttribute('Name');
                    // Now: Store all attributes for the tooltip
                    const itemData = {};
                    for (const attr of item.attributes) {
                        itemData[attr.name] = attr.value;
                    }
                    itemList[catIndex][itemIndex] = itemData;
                    // --- END MODIFIED ---
                }
            }
        }
        
        function parseMapDropXML(xmlText) {
            const parser = new DOMParser();
            const xmlDoc = parser.parseFromString(xmlText, 'text/xml');
            
            if (xmlDoc.getElementsByTagName('parsererror').length > 0) {
                console.error("XML Parsing Error for current file:", xmlDoc.getElementsByTagName('parsererror')[0].textContent);
            }

            const drops = [];
            const dropNodes = xmlDoc.getElementsByTagName('DropItem');
            
            for (const node of dropNodes) {
                
                const getAttr = (attr) => node.getAttribute(attr) || '-1';
                const getNumAttr = (attr) => node.getAttribute(attr) || '0';
                
                drops.push({
                    MonsterID: getAttr('MonsterID'),
                    MonsterElement: getAttr('MonsterElement'),
                    PlayerMinReset: getAttr('PlayerMinReset'),
                    PlayerMaxReset: getAttr('PlayerMaxReset'),
                    PlayerMinLevel: getAttr('PlayerMinLevel'),
                    PlayerMaxLevel: getAttr('PlayerMaxLevel'),
                    Cat: getAttr('Cat'),
                    Index: getAttr('Index'),
                    MinLevel: getNumAttr('MinLevel'),
                    MaxLevel: getNumAttr('MaxLevel'),
                    Durability: getNumAttr('Durability'),
                    Skill: getAttr('Skill'),
                    Luck: getAttr('Luck'),
                    Option: getNumAttr('Option'),
                    Exc: getAttr('Exc'),
                    Element: getNumAttr('Element'),
                    SocketCount: getNumAttr('SocketCount'),
                    Duration: getNumAttr('Duration'),
                    Rate: getNumAttr('Rate'),
                    isNew: false,
                    isModified: false,
                    originalName: node.getAttribute('Name') 
                });
            }
            
            return drops;
        }

        function renderMapFileList() {
            const fileListEl = document.getElementById('mapFileList');
            fileListEl.innerHTML = '';
            const sortedFiles = mapDropFiles.sort((a, b) => { 
                const numA = parseInt(a.match(/\((\d+)\)/)?.[1] || -1);
                const numB = parseInt(b.match(/\((\d+)\)/)?.[1] || -1);
                return numA - numB;
            });
            
            sortedFiles.forEach(filename => {
                const mapItem = document.createElement('div');
                const mapNum = parseInt(filename.match(/\((\d+)\)/)?.[1] || -1);
                const mapName = MAP_NAMES[mapNum] || 'Unknown Map'; 
                
                mapItem.className = 'map-item';
                mapItem.id = `map-item-${filename}`;
                mapItem.textContent = `(${mapNum}) ${mapName}`; 
                mapItem.dataset.filename = filename; 
                mapItem.onclick = () => selectMapFile(filename);
                fileListEl.appendChild(mapItem);
            });
        }

        function filterMapFiles() {
            const searchTerm = document.getElementById('mapSearch').value.toLowerCase();
            document.querySelectorAll('.map-item').forEach(item => {
                item.style.display = item.textContent.toLowerCase().includes(searchTerm) ? '' : 'none';
            });
        }
        
        async function selectMapFile(filename) { 
            if (currentFile === filename) return;
            
            selectedRows.clear();
            currentFile = filename;
            
            document.querySelectorAll('.map-item').forEach(item => item.classList.remove('active'));
            document.getElementById(`map-item-${filename}`).classList.add('active');
            
            let xmlText;
            
            document.getElementById('editorContent').innerHTML = `<div class="empty-state"><h3><i data-lucide="loader-2" class="spin"></i> Loading ${filename}...</h3><p>Fetching file content from server.</p></div>`;
            lucide.createIcons();
            document.querySelector('.spin')?.animate([{ transform: 'rotate(0deg)' }, { transform: 'rotate(360deg)' }], { duration: 1000, iterations: Infinity });
            
            try {
                if (fileContentCache[filename]) {
                    xmlText = fileContentCache[filename];
                } else {
                    const response = await fetch(`${SERVER_URL}/api/map-drop-file-content?filename=${filename}`);
                    if (!response.ok) {
                        const errorText = await response.text();
                        console.error(`Server error for ${filename}:`, errorText);
                        throw new Error(`Server responded with status ${response.status}. Message: ${errorText.substring(0, 200)}...`);
                    }
                    xmlText = await response.text();
                    fileContentCache[filename] = xmlText; 
                }

                
                const headerMatch = xmlText.match(/^[\s\S]*?(?=<MonsterMapItemDrop>)/i);
                originalXMLHeaders[filename] = headerMatch ? headerMatch[0] : '<?xml version="1.0" encoding="utf-8"?>\n';
                
                currentDropData = parseMapDropXML(xmlText);
                currentVisibleRows = ROWS_PER_PAGE; 
                
                history = [];
                historyIndex = -1;
                updateHistory(currentDropData); 

                renderEditorPanel();
                
            } catch (error) {
                console.error(`Failed to load file ${filename}:`, error);
                showStatus(`âœ— Error: Could not load file ${filename}. ${error.message}`, true);
                document.getElementById('editorContent').innerHTML = `<div class="empty-state"><h3>Load Failed</h3><p>Could not load ${filename}.</p><p style="color: var(--accent-pink); font-family: var(--font-data);">${error.message}</p></div>`;
            }
        }
        
        function renderEditorPanel() {
            selectedRows.clear();
            if (!currentFile) {
                document.getElementById('editorContent').innerHTML = `<div class="empty-state"><h3>Select a Map Bag File</h3><p>Choose a file from the list on the left to start editing drops.</p></div>`;
                return;
            }
            
            let html = `
                <div class="editor-panel-header">
                    <h2 style="color: var(--text-bright);">${currentFile}</h2>
                    <div class="search-bar">
                        <input type="text" id="dropSearch" oninput="filterDropTable()" placeholder="Search drops by Monster ID/Name or Item (Cat, Index) Name...">
                    </div>
                    <div class="controls" style="display: flex; gap: 10px; flex-wrap: wrap;">
                        <button class="btn btn-outline" onclick="openBulkModal()"><i data-lucide="wand-2"></i> Bulk Edit</button>
                        <button class="btn btn-outline" style="background-color: var(--accent-purple); color: white;" onclick="openRateAdjustModal()">
                            <i data-lucide="percent"></i> Adjust Rates
                        </button>
                        <button class="btn btn-danger" id="deleteSelectedBtn" onclick="deleteSelectedRows()" disabled><i data-lucide="trash-2"></i> Delete Selected (0)</button>
                        <button class="btn btn-primary" onclick="openAddModal()"><i data-lucide="plus-circle"></i> Add New Drop</button>
                        <button class="btn btn-success" onclick="saveChangesToServer()"><i data-lucide="save"></i> Save Changes</button>
                    </div>
                </div>
                <div class="table-wrapper">
                    <table id="dropTable" style="min-width: 1000px;">
                        <thead>
                            <tr>
                                <th class="checkbox-col"><input type="checkbox" id="selectAllCheckbox" onclick="toggleSelectAll(this.checked)" title="Select/Deselect All Visible"></th>
                                <th style="min-width: 200px;">Monster ID</th>
                                <th style="min-width: 200px;">Item (Cat_Index)</th>
                                <th>Rate</th>
                                <th>Min/Max Lvl</th>
                                <th>Exc</th>
                                <th>Socket</th>
                                <th>Actions</th>
                            </tr>
                        </thead>
                        <tbody>
                            ${currentDropData.length === 0 
                                ? `<tr><td colspan="8"><div class="empty-state"><h3>No Drop Items Found</h3><p>The selected file is empty or could not be parsed correctly.</p></div></td></tr>` 
                                : currentDropData.slice(0, currentVisibleRows).map((drop, index) => getDropRowHtml(drop, index)).join('')
                            }
                        </tbody>
                    </table>
                </div>
                
                <div class="load-more-container" id="loadMoreContainer">
                    ${currentVisibleRows < currentDropData.length ?
                        `<button class="btn btn-outline" onclick="loadMoreRows()">
                            <i data-lucide="arrow-down"></i>
                            Load ${Math.min(ROWS_PER_PAGE, currentDropData.length - currentVisibleRows)} More (${currentVisibleRows} / ${currentDropData.length})
                        </button>`
                        : ''
                    }
                </div>
            `;
            
            document.getElementById('editorContent').innerHTML = html;
            updateDeleteButtonState();
            lucide.createIcons();
            updateUndoRedoButtons(); 
        }

        function loadMoreRows() {
            currentVisibleRows += ROWS_PER_PAGE;
            renderEditorPanel();
        }
        
        function getDropRowHtml(drop, index) {
            const monsterName = monsterList[drop.MonsterID] || 'Unknown Monster';
            const catNum = parseInt(drop.Cat, 10);
            const indexNum = parseInt(drop.Index, 10);
            
            // --- MODIFIED ---
            // We now get the item object, which contains the name and all stats
            const item = (itemList[catNum] && itemList[catNum][indexNum]);
            const itemName = item ? item.Name : (drop.originalName || 'Unknown Item');
            // --- END MODIFIED ---
            
            let rowClass = drop.isNew ? 'spawn-row-new' : (drop.isModified ? 'spawn-row-modified' : '');
            if (selectedRows.has(index)) {
                rowClass += ' selected'; 
            }
            
            return `
                <tr data-index="${index}" class="${rowClass}">
                    <td class="checkbox-col">
                        <input type="checkbox" onclick="toggleRowSelection(${index}, this.checked)" ${selectedRows.has(index) ? 'checked' : ''} title="Select row ${index}">
                    </td>
                    <td class="monster-name-col"><span class="monster-name" title="[${drop.MonsterID}] ${monsterName}">[${drop.MonsterID}] ${monsterName}</span></td>
                    
                    <!-- --- MODIFIED --- -->
                    <!-- Removed title attribute, added onmouseover and onmouseout -->
                    <td class="item-name-col">
                        <span class="item-name" 
                              onmouseover="showTooltip(event, ${catNum}, ${indexNum})" 
                              onmouseout="hideTooltip()">
                              [${drop.Cat}_${drop.Index}] ${itemName}
                        </span>
                    </td>
                    <!-- --- END MODIFIED --- -->
                    
                    <td><input type="number" class="inline-input" value="${drop.Rate}" onchange="updateDropValue(${index}, 'Rate', this.value)"></td>
                    <td><input type="text" class="inline-input" value="${drop.MinLevel};${drop.MaxLevel}" onchange="updateMinMax(${index}, 'Level', this.value)"></td>
                    <td><input type="text" class="inline-input" value="${drop.Exc}" onchange="updateDropValue(${index}, 'Exc', this.value)"></td>
                    <td><input type="text" class="inline-input" value="${drop.SocketCount}" onchange="updateDropValue(${index}, 'SocketCount', this.value)"></td>
                    <td style="white-space: nowrap;">
                        <button class="action-btn btn-view" title="View / Edit" onclick="openViewModal(${index})"><i data-lucide="edit"></i></button>
                        <button class="action-btn btn-duplicate" title="Duplicate" onclick="duplicateDrop(${index})"><i data-lucide="copy"></i></button>
                        <button class="action-btn btn-delete" title="Delete" onclick="deleteDrop(${index})"><i data-lucide="trash-2"></i></button>
                    </td>
                </tr>
            `;
        }
        
        function updateDropValue(index, field, value) {
            updateHistory(currentDropData); 
            
            const drop = currentDropData[index];
            drop[field] = value;
            if (!drop.isNew) {
                drop.isModified = true;
                document.querySelector(`tr[data-index="${index}"]`).classList.add('spawn-row-modified');
            }
            updateHistory(currentDropData);
        }
        
        function updateMinMax(index, type, value) {
            updateHistory(currentDropData); 
            
            const parts = value.split(';').map(v => v.trim());
            const min = parts[0] || '0';
            const max = parts[1] || '0';
            const drop = currentDropData[index];
            
            if (type === 'Level') {
                drop.MinLevel = min;
                drop.MaxLevel = max;
            } else if (type === 'Reset') {
                drop.PlayerMinReset = min;
                drop.PlayerMaxReset = max;
            } else if (type === 'PLevel') {
                drop.PlayerMinLevel = min;
                drop.PlayerMaxLevel = max;
            }
            
            if (!drop.isNew) {
                drop.isModified = true;
                document.querySelector(`tr[data-index="${index}"]`).classList.add('spawn-row-modified');
            }
            updateHistory(currentDropData);
        }

        function filterDropTable() {
            const searchTerm = document.getElementById('dropSearch').value.toLowerCase();
            const table = document.getElementById('dropTable');
            table.querySelectorAll('tbody tr').forEach(row => {
                const index = row.dataset.index;
                const drop = currentDropData[index];
                if (!drop) {
                    row.style.display = 'none';
                    return;
                }
                
                const monsterName = (monsterList[drop.MonsterID] || '').toLowerCase();
                
                const catNum = parseInt(drop.Cat, 10);
                const indexNum = parseInt(drop.Index, 10);
                
                // --- MODIFIED ---
                const item = (itemList[catNum] && itemList[catNum][indexNum]);
                const itemName = item ? item.Name.toLowerCase() : (drop.originalName || '').toLowerCase();
                // --- END MODIFIED ---
                
                const itemKey = `${drop.Cat}_${drop.Index}`; 
                const fullItemName = `(${drop.Cat}, ${drop.Index}) ${itemName}`; 

                const isVisible = 
                    drop.MonsterID.toLowerCase().includes(searchTerm) ||
                    monsterName.includes(searchTerm) ||
                    itemKey.includes(searchTerm) || 
                    itemName.includes(searchTerm) || 
                    fullItemName.toLowerCase().includes(searchTerm); 
                    
                row.style.display = isVisible ? '' : 'none';
            });

            selectedRows.clear();
            updateDeleteButtonState();
            const selectAllCheckbox = document.getElementById('selectAllCheckbox');
            if (selectAllCheckbox) selectAllCheckbox.checked = false;
        }
        
        function openAddModal() {
            editingDropIndex = null;
            document.getElementById('modalTitle').textContent = 'Add New Drop Item';
            document.getElementById('dropForm').reset();
            document.getElementById('monsterID').value = '';
            document.getElementById('itemCat').value = '';
            document.getElementById('itemIndex').value = '';
            
            document.getElementById('monsterElement').value = '-1';
            document.getElementById('playerMinReset').value = '-1';
            document.getElementById('playerMaxReset').value = '-1';
            document.getElementById('playerMinLevel').value = '-1';
            document.getElementById('playerMaxLevel').value = '-1';
            document.getElementById('minLevel').value = '0';
            document.getElementById('maxLevel').value = '0';
            document.getElementById('durability').value = '0';
            document.getElementById('skill').value = '-1';
            document.getElementById('luck').value = '-1';
            document.getElementById('option').value = '0';
            document.getElementById('exc').value = '-1';
            document.getElementById('element').value = '0';
            document.getElementById('socketCount').value = '0;0';
            document.getElementById('duration').value = '0';
            document.getElementById('rate').value = '1000';
            
            document.getElementById('dropModal').classList.add('show');
            lucide.createIcons();
        }
        
        function openViewModal(index) {
            editingDropIndex = index;
            const drop = currentDropData[index];
            if (!drop) return;

            document.getElementById('modalTitle').textContent = 'View / Edit Drop Item';
            
            const monsterName = monsterList[drop.MonsterID] || 'Unknown';
            document.getElementById('monsterSearch').value = `[${drop.MonsterID}] ${monsterName}`;
            document.getElementById('monsterID').value = drop.MonsterID;
            
            const catNum = parseInt(drop.Cat, 10);
            const indexNum = parseInt(drop.Index, 10);
            
            // --- MODIFIED ---
            const item = (itemList[catNum] && itemList[catNum][indexNum]);
            const itemName = item ? item.Name : (drop.originalName || 'Unknown');
            // --- END MODIFIED ---
            
            document.getElementById('itemSearch').value = `[${drop.Cat}_${drop.Index}] ${itemName}`;
            document.getElementById('itemCat').value = drop.Cat;
            document.getElementById('itemIndex').value = drop.Index;

            document.getElementById('monsterElement').value = drop.MonsterElement;
            document.getElementById('playerMinReset').value = drop.PlayerMinReset;
            document.getElementById('playerMaxReset').value = drop.PlayerMaxReset;
            document.getElementById('playerMinLevel').value = drop.PlayerMinLevel;
            document.getElementById('playerMaxLevel').value = drop.PlayerMaxLevel;
            document.getElementById('minLevel').value = drop.MinLevel;
            document.getElementById('maxLevel').value = drop.MaxLevel;
            document.getElementById('durability').value = drop.Durability;
            document.getElementById('skill').value = drop.Skill;
            document.getElementById('luck').value = drop.Luck;
            document.getElementById('option').value = drop.Option;
            document.getElementById('exc').value = drop.Exc;
            document.getElementById('element').value = drop.Element;
            document.getElementById('socketCount').value = drop.SocketCount;
            document.getElementById('duration').value = drop.Duration;
            document.getElementById('rate').value = drop.Rate;
            
            document.getElementById('dropModal').classList.add('show');
            lucide.createIcons();
        }
        
        function closeModal() {
            document.getElementById('dropModal').classList.remove('show');
        }
        
        function openBulkModal() {
            if (!currentFile) {
                showStatus('Please select a map file first.', true);
                return;
            }
            document.getElementById('bulkEditForm').reset();
            document.getElementById('bulkFindMonsterID').value = '';
            document.getElementById('bulkFindItemCat').value = '';
            document.getElementById('bulkFindItemIndex').value = '';
            document.getElementById('bulkReplaceItemCat').value = '';
            document.getElementById('bulkReplaceItemIndex').value = '';
            
            const findSection = document.getElementById('bulkFindSection');
            const title = document.getElementById('bulkModalTitle');
            const findMonsterInput = document.getElementById('bulkFindMonsterSearch');
            
            if (selectedRows.size > 0) {
                title.textContent = `Bulk Edit ${selectedRows.size} Selected Drops`;
                findSection.style.display = 'none';
                findMonsterInput.required = false;
            } else {
                title.textContent = 'Bulk Edit All Drops';
                findSection.style.display = 'block';
                findMonsterInput.required = true;
            }

            document.getElementById('bulkEditModal').classList.add('show');
            lucide.createIcons();
        }
        
        function closeBulkModal() {
            document.getElementById('bulkEditModal').classList.remove('show');
        }

        
        function openRateAdjustModal() {
            if (!currentFile) {
                showStatus('Please select a map file first.', true);
                return;
            }
            document.getElementById('rateAdjustForm').reset();
            // document.getElementById('rateAdjustFileName').textContent = currentFile; // <-- This line is redundant and causes the error
            
            const title = document.getElementById('rateAdjustModalTitle');
            const info = document.getElementById('rateAdjustInfo');
            const count = selectedRows.size;

            if (count > 0) {
                title.textContent = `Adjust Rates for ${count} Selected Drops`;
                info.innerHTML = `This will multiply the rates for the <strong>${count} selected items</strong> by a percentage.`;
            } else {
                title.textContent = 'Adjust All Drop Rates';
                info.innerHTML = `This will multiply all drop rates in the current file (<strong><span id="rateAdjustFileName">${currentFile}</span></strong>) by a percentage.`;
            }
            
            calculateRateChange(); 
            document.getElementById('rateAdjustModal').classList.add('show');
            lucide.createIcons();
        }
        
        function closeRateAdjustModal() {
            document.getElementById('rateAdjustModal').classList.remove('show');
        }

        function calculateRateChange() {
            const percentInput = document.getElementById('rateAdjustPercent');
            const previewEl = document.getElementById('rateAdjustPreview');
            const percent = parseFloat(percentInput.value);
            
            const operatingOnSelected = selectedRows.size > 0;
            const dataToScan = operatingOnSelected ? Array.from(selectedRows).map(i => currentDropData[i]) : currentDropData;

            let currentTotal = 0;
            dataToScan.forEach(drop => {
                if (drop) currentTotal += parseInt(drop.Rate, 10) || 0;
            });

            if (isNaN(percent) || percent <= 0) {
                previewEl.innerHTML = `
                    <p style="font-weight: 600; color: var(--text-primary);">Current Total Rate (for ${operatingOnSelected ? 'selected' : 'all'} items): <span style="font-family: var(--font-data);">${currentTotal.toLocaleString()}</span></p>
                    <p style="color: var(--text-secondary);">Enter a valid percentage (e.g., '50' or '150') to see the new total.</p>
                `;
                return;
            }

            const multiplier = percent / 100;
            let newTotal = 0;
            const GLOBAL_MAX_TOTAL = 100000000; 
            
            dataToScan.forEach(drop => {
                if (!drop) return;
                const oldRate = parseInt(drop.Rate, 10) || 0;
                if (oldRate > 0) {
                    let newRate = Math.round(oldRate * multiplier);
                    if (newRate === 0) newRate = 1; 
                    if (newRate > 1000000) newRate = 1000000; 
                    newTotal += newRate;
                } else {
                    newTotal += oldRate; 
                }
            });

            let warningHtml = '';
            if (!operatingOnSelected && newTotal > GLOBAL_MAX_TOTAL) {
                warningHtml = `<p style="font-weight: 600; color: var(--accent-pink); margin-top: 10px;"><i data-lucide="alert-triangle" style="width: 14px; height: 14px; vertical-align: -2px;"></i> WARNING: New total exceeds the ${GLOBAL_MAX_TOTAL.toLocaleString()} limit!</p>`;
            }

            previewEl.innerHTML = `
                <p style="font-weight: 600; color: var(--text-primary);">Current Total Rate (for ${operatingOnSelected ? selectedRows.size : 'all'} items): <span style="font-family: var(--font-data);">${currentTotal.toLocaleString()}</span></p>
                <p style="font-weight: 600; color: var(--accent-blue);">New Estimated Total Rate: <span style="font-family: var(--font-data);">${newTotal.toLocaleString()}</span></p>
                ${warningHtml}
            `;
            if (warningHtml) lucide.createIcons();
        }

        document.getElementById('rateAdjustForm').addEventListener('submit', function(e) {
            e.preventDefault();
            
            updateHistory(currentDropData); 

            const percentInput = document.getElementById('rateAdjustPercent');
            const percent = parseFloat(percentInput.value);

            if (isNaN(percent) || percent <= 0) {
                showStatus("Please enter a valid percentage greater than 0.", true);
                return;
            }
            
            const multiplier = percent / 100;
            let newTotal = 0;
            let itemsChanged = 0;
            const GLOBAL_MAX_TOTAL = 100000000;
            
            const operatingOnSelected = selectedRows.size > 0;
            const indicesToUpdate = operatingOnSelected ? Array.from(selectedRows) : currentDropData.map((_, i) => i);

            indicesToUpdate.forEach(index => {
                const drop = currentDropData[index];
                if (!drop) return;
                
                const oldRate = parseInt(drop.Rate, 10) || 0;
                if (oldRate > 0) {
                    let newRate = Math.round(oldRate * multiplier);
                    if (newRate === 0) newRate = 1; 
                    if (newRate > 1000000) newRate = 1000000; 
                    
                    if (oldRate !== newRate) {
                        drop.Rate = newRate;
                        if (!drop.isNew) {
                            drop.isModified = true;
                        }
                        itemsChanged++;
                    }
                    newTotal += newRate;
                } else {
                    newTotal += oldRate; 
                }
            });
            
            if (!operatingOnSelected && newTotal > GLOBAL_MAX_TOTAL) {
                showStatus(`Warning: Rates adjusted by ${percent}%. New total ${newTotal.toLocaleString()} exceeds ${GLOBAL_MAX_TOTAL.toLocaleString()}.`, false, true);
            } else {
                showStatus(`âœ“ Rates for ${itemsChanged} item(s) adjusted by ${percent}%.`, false);
            }
            
            closeRateAdjustModal();
            renderEditorPanel(); 
            updateHistory(currentDropData); 
        });

        function deleteDrop(index) {
            confirmAction(
                'Delete Drop?',
                'Are you sure you want to delete this drop item?',
                () => {
                    updateHistory(currentDropData); 
                    selectedRows.delete(index);
                    currentDropData.splice(index, 1);
                    renderEditorPanel(); 
                    updateHistory(currentDropData); 
                }
            );
        }
        
        function duplicateDrop(index) {
            updateHistory(currentDropData); 

            const originalDrop = currentDropData[index];
            const newDrop = JSON.parse(JSON.stringify(originalDrop));
            newDrop.isNew = true;
            delete newDrop.isModified;
            currentDropData.splice(index + 1, 0, newDrop);
            renderEditorPanel(); 
            updateHistory(currentDropData); 
        }

        function updateDeleteButtonState() {
            const btn = document.getElementById('deleteSelectedBtn');
            if (btn) {
                const count = selectedRows.size;
                btn.disabled = count === 0;
                btn.innerHTML = `<i data-lucide="trash-2"></i> Delete Selected (${count})`;
                lucide.createIcons();
            }
        }

        function toggleRowSelection(index, isChecked) {
            const row = document.querySelector(`tr[data-index="${index}"]`);
            if (isChecked) {
                selectedRows.add(index);
                row?.classList.add('selected');
            } else {
                selectedRows.delete(index);
                row?.classList.remove('selected');
            }
            updateDeleteButtonState();
        }

        function toggleSelectAll(isChecked) {
            const table = document.getElementById('dropTable');
            table.querySelectorAll('tbody tr').forEach(row => {
                if (row.style.display !== 'none') {
                    const index = parseInt(row.dataset.index, 10);
                    const checkbox = row.querySelector('input[type="checkbox"]');
                    if (isChecked) {
                        selectedRows.add(index);
                        row.classList.add('selected');
                        if (checkbox) checkbox.checked = true;
                    } else {
                        selectedRows.delete(index);
                        row.classList.remove('selected');
                        if (checkbox) checkbox.checked = false;
                    }
                }
            });
            updateDeleteButtonState();
        }

        function deleteSelectedRows() {
            const count = selectedRows.size;
            if (count === 0) return;

            confirmAction(
                'Delete Selected Drops?',
                `Are you sure you want to delete ${count} selected drop item(s)?`,
                () => {
                    updateHistory(currentDropData);
                    
                    currentDropData = currentDropData.filter((drop, index) => !selectedRows.has(index));
                    
                    selectedRows.clear();
                    
                    renderEditorPanel(); 
                    
                    updateHistory(currentDropData);
                    
                    showStatus(`âœ“ ${count} drop(s) deleted.`, false);
                }
            );
        }

        document.getElementById('monsterSearch').addEventListener('input', function(e) {
            const searchTerm = e.target.value.toLowerCase();
            const suggestionsDiv = document.getElementById('monsterSuggestions');
            let html = '';
            let count = 0;
            if (searchTerm.length > 0) {
                for (const [id, name] of Object.entries(monsterList)) {
                    if (count >= 10) break;
                    if (id.includes(searchTerm) || name.toLowerCase().includes(searchTerm)) {
                        html += `<div class="suggestion-item" onclick="selectMonster('${id}', '${name.replace(/'/g, "\\'")}')"><span class="suggestion-item-id">${id}</span> ${name}</div>`;
                        count++;
                    }
                }
            }
            suggestionsDiv.innerHTML = html;
            suggestionsDiv.classList.toggle('show', !!html);
        });

        function selectMonster(id, name) {
            document.getElementById('monsterSearch').value = `[${id}] ${name}`;
            document.getElementById('monsterID').value = id;
            document.getElementById('monsterSuggestions').classList.remove('show');
        }
        
        document.getElementById('itemSearch').addEventListener('input', function(e) {
            let html = '';
            let count = 0;
            const searchTerm = e.target.value.toLowerCase();
            const suggestions = document.getElementById('itemSuggestions');
            
            if (searchTerm.length < 2) {
                suggestions.classList.remove('show');
                return;
            }
            
            for (const [catIndex, items] of Object.entries(itemList)) {
                if (count >= 50) break;
                for (const [itemIndex, itemName] of Object.entries(items)) {
                    if (count >= 50) break;
                    
                    // --- MODIFIED ---
                    // itemName is now an object, so we get itemName.Name
                    const itemObj = itemName; // Keep the name 'itemName' from the loop, but clarify it's an object
                    const fullItemName = `(${catIndex}, ${itemIndex}) ${itemObj.Name}`;
                    if (fullItemName.toLowerCase().includes(searchTerm)) {
                        const escapedName = itemObj.Name.replace(/'/g, "\\'").replace(/"/g, "&quot;");
                        // --- END MODIFIED ---
                        
                        const catName = itemCategories[catIndex] || 'Cat ' + catIndex;
                        html += `<div class="suggestion-item" onclick="selectItem('${catIndex}', '${itemIndex}', '${escapedName}')">
                                    <span class="suggestion-item-cat">${catName}</span> 
                                    <span class="suggestion-item-id">(${catIndex}, ${itemIndex})</span> ${itemObj.Name}
                                   </div>`;
                        count++;
                    }
                }
            }
            suggestions.innerHTML = html;
            suggestions.classList.toggle('show', !!html);
        });

        function selectItem(cat, index, name) {
            document.getElementById('itemSearch').value = `[${cat}_${index}] ${name}`;
            document.getElementById('itemCat').value = cat;
            document.getElementById('itemIndex').value = index;
            document.getElementById('itemSuggestions').classList.remove('show');
        }
        
        document.getElementById('bulkFindMonsterSearch').addEventListener('input', function(e) {
            const searchTerm = e.target.value.toLowerCase();
            const suggestionsDiv = document.getElementById('bulkFindMonsterSuggestions');
            let html = '';
            let count = 0;
            if (searchTerm.length > 0) {
                for (const [id, name] of Object.entries(monsterList)) {
                    if (count >= 10) break;
                    if (id.includes(searchTerm) || name.toLowerCase().includes(searchTerm)) {
                        html += `<div class="suggestion-item" onclick="selectBulkMonster('Find', '${id}', '${name.replace(/'/g, "\\'")}')"><span class="suggestion-item-id">${id}</span> ${name}</div>`;
                        count++;
                    }
                }
            }
            suggestionsDiv.innerHTML = html;
            suggestionsDiv.classList.toggle('show', !!html);
        });

        document.getElementById('bulkFindItemSearch').addEventListener('input', function(e) {
            let html = '';
            let count = 0;
            const searchTerm = e.target.value.toLowerCase();
            const suggestions = document.getElementById('bulkFindItemSuggestions');
            
            if (searchTerm.length < 2) {
                suggestions.classList.remove('show');
                return;
            }
            
            for (const [catIndex, items] of Object.entries(itemList)) {
                if (count >= 10) break;
                for (const [itemIndex, itemName] of Object.entries(items)) {
                    if (count >= 10) break;
                    
                    // --- MODIFIED ---
                    const itemObj = itemName; 
                    const fullItemName = `(${catIndex}, ${itemIndex}) ${itemObj.Name}`;
                    if (fullItemName.toLowerCase().includes(searchTerm)) {
                        const escapedName = itemObj.Name.replace(/'/g, "\\'").replace(/"/g, "&quot;");
                        // --- END MODIFIED ---
                        
                        const catName = itemCategories[catIndex] || 'Cat ' + catIndex;
                        html += `<div class="suggestion-item" onclick="selectBulkItem('Find', '${catIndex}', '${itemIndex}', '${escapedName}')">
                                    <span class="suggestion-item-cat">${catName}</span> 
                                    <span class="suggestion-item-id">(${catIndex}, ${itemIndex})</span> ${itemObj.Name}
                                   </div>`;
                        count++;
                    }
                }
            }
            suggestions.innerHTML = html;
            suggestions.classList.toggle('show', !!html);
        });

        document.getElementById('bulkReplaceItemSearch').addEventListener('input', function(e) {
            let html = '';
            let count = 0;
            const searchTerm = e.target.value.toLowerCase();
            const suggestions = document.getElementById('bulkReplaceItemSuggestions');
            
            if (searchTerm.length < 2) {
                suggestions.classList.remove('show');
                return;
            }
            
            for (const [catIndex, items] of Object.entries(itemList)) {
                if (count >= 10) break;
                for (const [itemIndex, itemName] of Object.entries(items)) {
                    if (count >= 10) break;
                    
                    // --- MODIFIED ---
                    const itemObj = itemName; 
                    const fullItemName = `(${catIndex}, ${itemIndex}) ${itemObj.Name}`;
                    if (fullItemName.toLowerCase().includes(searchTerm)) {
                        const escapedName = itemObj.Name.replace(/'/g, "\\'").replace(/"/g, "&quot;");
                        // --- END MODIFIED ---
                        
                        const catName = itemCategories[catIndex] || 'Cat ' + catIndex;
                        html += `<div class="suggestion-item" onclick="selectBulkItem('Replace', '${catIndex}', '${itemIndex}', '${escapedName}')">
                                    <span class="suggestion-item-cat">${catName}</span> 
                                    <span class="suggestion-item-id">(${catIndex}, ${itemIndex})</span> ${itemObj.Name}
                                   </div>`;
                        count++;
                    }
                }
            }
            suggestions.innerHTML = html;
            suggestions.classList.toggle('show', !!html);
        });

        function selectBulkMonster(type, id, name) {
            document.getElementById(`bulk${type}MonsterSearch`).value = `[${id}] ${name}`;
            document.getElementById(`bulk${type}MonsterID`).value = id;
            document.getElementById(`bulk${type}MonsterSuggestions`).classList.remove('show');
        }

        function selectBulkItem(type, cat, index, name) {
            document.getElementById(`bulk${type}ItemSearch`).value = `[${cat}_${index}] ${name}`;
            document.getElementById(`bulk${type}ItemCat`).value = cat;
            document.getElementById(`bulk${type}ItemIndex`).value = index;
            document.getElementById(`bulk${type}ItemSuggestions`).classList.remove('show');
        }


        document.getElementById('dropForm').addEventListener('submit', function(e) {
            e.preventDefault();
            
            updateHistory(currentDropData); 

            const monsterID = document.getElementById('monsterID').value;
            let itemCat = document.getElementById('itemCat').value;
            let itemIndex = document.getElementById('itemIndex').value;
            
            if (!monsterID) {
                showStatus('You must select a monster.', true);
                return;
            }
            if (itemCat === '' || itemIndex === '') {
                const itemSearchText = document.getElementById('itemSearch').value;
                const match = itemSearchText.match(/\[(\d+)_(\d+)\]/); 
                if (match) {
                    itemCat = match[1];
                    itemIndex = match[2];
                } else {
                    showStatus('You must select a valid item from the search.', true);
                    return;
                }
            }

            const dropData = {
                MonsterID: document.getElementById('monsterID').value,
                MonsterElement: document.getElementById('monsterElement').value,
                PlayerMinReset: document.getElementById('playerMinReset').value,
                PlayerMaxReset: document.getElementById('playerMaxReset').value,
                PlayerMinLevel: document.getElementById('playerMinLevel').value,
                PlayerMaxLevel: document.getElementById('playerMaxLevel').value,
                Cat: itemCat,
                Index: itemIndex,
                MinLevel: document.getElementById('minLevel').value,
                MaxLevel: document.getElementById('maxLevel').value,
                Durability: document.getElementById('durability').value,
                Skill: document.getElementById('skill').value,
                Luck: document.getElementById('luck').value,
                Option: document.getElementById('option').value,
                Exc: document.getElementById('exc').value,
                Element: document.getElementById('element').value,
                SocketCount: document.getElementById('socketCount').value,
                Duration: document.getElementById('duration').value,
                Rate: document.getElementById('rate').value
            };

            if (editingDropIndex !== null) {
                const originalDrop = currentDropData[editingDropIndex];
                currentDropData[editingDropIndex] = {
                    ...originalDrop, 
                    ...dropData,    
                    isModified: !originalDrop.isNew, 
                    isNew: originalDrop.isNew 
                };
            } else {
                currentDropData.unshift({
                    ...dropData,
                    isNew: true,
                    isModified: false
                }); 
            }
            
            renderEditorPanel();
            closeModal();
            updateHistory(currentDropData); 
        });

        document.getElementById('bulkEditForm').addEventListener('submit', function(e) {
            e.preventDefault();

            updateHistory(currentDropData); 

            const operatingOnSelected = selectedRows.size > 0;

            const findMonsterID = document.getElementById('bulkFindMonsterID').value;
            const findItemCat = document.getElementById('bulkFindItemCat').value;
            const findItemIndex = document.getElementById('bulkFindItemIndex').value;
            
            const replaceItemCat = document.getElementById('bulkReplaceItemCat').value;
            const replaceItemIndex = document.getElementById('bulkReplaceItemIndex').value;
            const replaceItemSet = (replaceItemCat !== "" && replaceItemIndex !== "");
            
            const newValues = {
                MinLevel: document.getElementById('bulkMinLevel').value,
                MaxLevel: document.getElementById('bulkMaxLevel').value,
                Durability: document.getElementById('bulkDurability').value,
                Skill: document.getElementById('bulkSkill').value,
                Luck: document.getElementById('bulkLuck').value,
                Option: document.getElementById('bulkOption').value,
                Exc: document.getElementById('bulkExc').value,
                SocketCount: document.getElementById('bulkSocketCount').value,
                Duration: document.getElementById('bulkDuration').value,
                Rate: document.getElementById('bulkRate').value
            };
            
            const isValueChange = Object.values(newValues).some(v => v !== null && v !== "");
            
            if (!operatingOnSelected && !findMonsterID) {
                showStatus('You must select a Monster to find (or select rows first).', true);
                return;
            }
            if (!replaceItemSet && !isValueChange) {
                 showStatus('You must either select a New Item or fill out at least one new value.', true);
                 return;
            }

            let updatedCount = 0;
            
            if (operatingOnSelected) {
                for (const index of selectedRows) {
                    const drop = currentDropData[index];
                    if (!drop) continue;
                    
                    updatedCount++;

                    if (replaceItemSet) {
                        drop.Cat = replaceItemCat;
                        drop.Index = replaceItemIndex;
                    }

                    for (const [key, value] of Object.entries(newValues)) {
                        if (value !== null && value !== "") { 
                            drop[key] = value;
                        }
                    }

                    if (!drop.isNew) {
                        drop.isModified = true;
                    }
                }
            } else {
                const findItemKey = (findItemCat && findItemIndex) ? `${findItemCat}_${findItemIndex}` : null;
                
                currentDropData.forEach(drop => {
                    let monsterMatch = (drop.MonsterID === findMonsterID);
                    let itemMatch = true; 

                    if (findItemKey) {
                        itemMatch = (drop.Cat === findItemCat && drop.Index === findItemIndex);
                    }

                    if (monsterMatch && itemMatch) {
                        updatedCount++;

                        if (replaceItemSet) {
                            drop.Cat = replaceItemCat;
                            drop.Index = replaceItemIndex;
                        }

                        for (const [key, value] of Object.entries(newValues)) {
                            if (value !== null && value !== "") { 
                                drop[key] = value;
                            }
                        }

                        if (!drop.isNew) {
                            drop.isModified = true;
                        }
                    }
                });
            }


            if (updatedCount > 0) {
                showStatus(`âœ“ Bulk edit complete. Updated ${updatedCount} drop(s).`, false);
                renderEditorPanel(); 
            } else {
                showStatus('No matching drops found for that criteria.', false, true); 
            }

            closeBulkModal();
            updateHistory(currentDropData); 
        });


        function openGuideModal() { document.getElementById('guideModal').classList.add('show'); lucide.createIcons(); }
        function closeGuideModal() { document.getElementById('guideModal').classList.remove('show'); }
        
        document.getElementById('dropModal').addEventListener('click', function (e) { if (e.target === this) closeModal(); }); 
        document.getElementById('guideModal').addEventListener('click', function (e) { if (e.target === this) closeGuideModal(); }); 
        document.getElementById('confirmModal').addEventListener('click', function (e) { if (e.target === this) closeConfirmModal(); }); 
        document.getElementById('bulkEditModal').addEventListener('click', function (e) { if (e.target === this) closeBulkModal(); }); 
        document.getElementById('rateAdjustModal').addEventListener('click', function (e) { if (e.target === this) closeRateAdjustModal(); }); 

        
        document.addEventListener('click', function (e) { 
            if (!e.target.closest('.monster-search')) {
                document.getElementById('monsterSuggestions').classList.remove('show');
                if (document.getElementById('bulkFindMonsterSuggestions')) {
                    document.getElementById('bulkFindMonsterSuggestions').classList.remove('show'); 
                }
            }
            if (!e.target.closest('.item-search')) {
                document.getElementById('itemSuggestions').classList.remove('show');
                if (document.getElementById('bulkFindItemSuggestions')) {
                    document.getElementById('bulkFindItemSuggestions').classList.remove('show'); 
                }
                if (document.getElementById('bulkReplaceItemSuggestions')) {
                    document.getElementById('bulkReplaceItemSuggestions').classList.remove('show'); 
                }
            }
        });
        
        function buildXmlFromData() {
            let xml = originalXMLHeaders[currentFile] || '<?xml version="1.0" encoding="utf-8"?>\n';
            xml += '<MonsterMapItemDrop>\n';
            
            for (const drop of currentDropData) {
                const catNum = parseInt(drop.Cat, 10);
                const indexNum = parseInt(drop.Index, 10);
                const itemName = (itemList[catNum] && itemList[catNum][indexNum]) || drop.originalName || 'Unknown Item';
                xml += `  <!-- ${itemName} -->\n`;
                xml += `  <DropItem MonsterID="${drop.MonsterID}" MonsterElement="${drop.MonsterElement}" PlayerMinReset="${drop.PlayerMinReset}" PlayerMaxReset="${drop.PlayerMaxReset}" PlayerMinLevel="${drop.PlayerMinLevel}" PlayerMaxLevel="${drop.PlayerMaxLevel}" Cat="${drop.Cat}" Index="${drop.Index}" MinLevel="${drop.MinLevel}" MaxLevel="${drop.MaxLevel}" Durability="${drop.Durability}" Skill="${drop.Skill}" Luck="${drop.Luck}" Option="${drop.Option}" Exc="${drop.Exc}" Element="${drop.Element}" SocketCount="${drop.SocketCount}" Duration="${drop.Duration}" Rate="${drop.Rate}" />\n`;
            }
            
            xml += '</MonsterMapItemDrop>';
            return xml;
        }
        
        // --- NEW Tooltip Functions ---

        const tooltipEl = document.getElementById('itemTooltip');

        function showTooltip(event, cat, index) {
            const item = (itemList[cat] && itemList[cat][index]);
            if (!item || !tooltipEl) return;

            tooltipEl.innerHTML = buildTooltipHtml(item);
            tooltipEl.style.display = 'block';

            // Position the tooltip
            let x = event.pageX + 15;
            let y = event.pageY + 15;

            // Prevent tooltip from going off-screen
            if (x + tooltipEl.offsetWidth > window.innerWidth) {
                x = event.pageX - tooltipEl.offsetWidth - 15;
            }
            if (y + tooltipEl.offsetHeight > window.innerHeight) {
                y = event.pageY - tooltipEl.offsetHeight - 15;
            }

            tooltipEl.style.left = `${x}px`;
            tooltipEl.style.top = `${y}px`;
        }

        function hideTooltip() {
            if (tooltipEl) {
                tooltipEl.style.display = 'none';
            }
        }

        function buildTooltipHtml(item) {
            let html = `<h3>${item.Name}</h3>`;

            const addStat = (label, value) => {
                const numValue = parseInt(value, 10);
                if (value !== undefined && value !== "0" && value !== "-1" && numValue > 0) {
                    return `<div class="stat"><strong>${label}:</strong> <span>${value}</span></div>`;
                }
                return '';
            };

            // --- Primary Stats (Weapons/Armor) ---
            let primaryStats = '';
            primaryStats += addStat("Min Dmg", item.MinDamage);
            primaryStats += addStat("Max Dmg", item.MaxDamage);
            primaryStats += addStat("Atk Speed", item.AttackSpeed);
            primaryStats += addStat("Defense", item.Defense);
            primaryStats += addStat("Magic Def", item.MagicDefense);
            primaryStats += addStat("Durability", item.Durability);

            if (primaryStats) {
                html += `<div class="stats-grid">${primaryStats}</div>`;
            }

            // --- Requirements ---
            let reqStats = '';
            reqStats += addStat("Req Level", item.ReqLevel);
            reqStats += addStat("Req Str", item.ReqStrength);
            reqStats += addStat("Req Agi", item.ReqAgility);
            reqStats += addStat("Req Ene", item.ReqEnergy);
            reqStats += addStat("Req Vit", item.ReqVitality);
            reqStats += addStat("Req Cmd", item.ReqCommand);

            if (reqStats) {
                html += '<hr class="stat-divider">';
                html += `<div class="stats-grid reqs">${reqStats}</div>`;
            }

            // --- Class List ---
            const classes = [
                { key: 'DarkWizard', name: 'DW/SM/GM' },
                { key: 'DarkKnight', name: 'DK/BK/BM' },
                { key: 'FairyElf', name: 'Elf/ME/HE' },
                { key: 'MagicGladiator', name: 'MG/DM' },
                { key: 'DarkLord', name: 'DL/LE' },
                { key: 'Summoner', name: 'Sum/BS/DiM' },
                { key: 'RageFighter', name: 'RF/FM' },
                { key: 'GrowLancer', name: 'GL/ML' },
                { key: 'RuneWizard', name: 'RW/RM' },
                { key: 'Slayer', name: 'Slayer/RS' },
                { key: 'GunCrusher', name: 'GC/MaG' },
                { key: 'LightWizard', name: 'LW/LM' },
                { key: 'LemuriaMage', name: 'Lemuria' },
                { key: 'IllusionKnight', name: 'IK' },
                { key: 'Alchemist', name: 'Alchemist' }
            ];

            const usableClasses = classes
                .filter(c => item[c.key] === "1")
                .map(c => c.name);

            if (usableClasses.length > 0 && usableClasses.length < classes.length) { // Only show if not all classes
                html += '<hr class="stat-divider">';
                html += `<div class="class-list"><strong>Classes:</strong> <span>${usableClasses.join(', ')}</span></div>`;
            }

            return html;
        }
        
        // --- End NEW Tooltip Functions ---
        
        function buildXmlFromData() {
            let xml = originalXMLHeaders[currentFile] || '<?xml version="1.0" encoding="utf-8"?>\n';
            xml += '<MonsterMapItemDrop>\n';
            
            for (const drop of currentDropData) {
                const catNum = parseInt(drop.Cat, 10);
                const indexNum = parseInt(drop.Index, 10);
                
                // --- MODIFIED ---
                const item = (itemList[catNum] && itemList[catNum][indexNum]);
                const itemName = item ? item.Name : (drop.originalName || 'Unknown Item');
                // --- END MODIFIED ---
                
                xml += `  <!-- ${itemName} -->\n`;
                xml += `  <DropItem MonsterID="${drop.MonsterID}" MonsterElement="${drop.MonsterElement}" PlayerMinReset="${drop.PlayerMinReset}" PlayerMaxReset="${drop.PlayerMaxReset}" PlayerMinLevel="${drop.PlayerMinLevel}" PlayerMaxLevel="${drop.PlayerMaxLevel}" Cat="${drop.Cat}" Index="${drop.Index}" MinLevel="${drop.MinLevel}" MaxLevel="${drop.MaxLevel}" Durability="${drop.Durability}" Skill="${drop.Skill}" Luck="${drop.Luck}" Option="${drop.Option}" Exc="${drop.Exc}" Element="${drop.Element}" SocketCount="${drop.SocketCount}" Duration="${drop.Duration}" Rate="${drop.Rate}" />\n`;
            }
            
            xml += '</MonsterMapItemDrop>';
            return xml;
        }
        
        async function saveChangesToServer() { 
            if (!currentFile) {
                showStatus('No file selected to save.', true);
                return;
            }
            
            const saveButton = document.querySelector('.btn-success'); 
            saveButton.disabled = true; 
            saveButton.innerHTML = `<i data-lucide="loader-2" class="spin"></i> Saving...`; 
            lucide.createIcons(); 
            document.querySelectorAll('.spin').forEach(el => el.animate([{ transform: 'rotate(0deg)' }, { transform: 'rotate(360deg)' }], { duration: 1000, iterations: Infinity }));
            
            const newXmlContent = buildXmlFromData();
            
            try { 
                const response = await fetch(`${SERVER_URL}/api/save-map-drop-file`, { 
                    method: 'POST', 
                    headers: { 'Content-Type': 'application/json' }, 
                    body: JSON.stringify({ 
                        filename: currentFile,
                        newXmlContent: newXmlContent 
                    }), 
                }); 
                if (!response.ok) {
                    const errorText = await response.text();
                    console.error('Server error on save:', errorText);
                    throw new Error(`Server responded with status: ${response.status}. Message: ${errorText.substring(0, 200)}...`);
                }
                
                showStatus(`âœ“ ${currentFile} saved successfully to the server!`, false);
                
                fileContentCache[currentFile] = newXmlContent;
                currentDropData = parseMapDropXML(newXmlContent); 
                currentVisibleRows = ROWS_PER_PAGE; 
                
                history = [];
                historyIndex = -1;
                updateHistory(currentDropData);

                renderEditorPanel(); 
                
            } catch (error) { 
                console.error('Failed to save changes:', error); 
                showStatus(`âœ— Error: Could not save ${currentFile}. ${error.message}`, true); 
            } finally { 
                saveButton.disabled = false; 
                saveButton.innerHTML = `<i data-lucide="save"></i> Save Changes`; 
                lucide.createIcons(); 
            } 
        }
    </script>
</body>
</html>